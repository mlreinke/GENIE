<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>GENIE - GENPOS</TITLE>
</head>
 
<body>
<H1>GENIE - GENPOS</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Fri Jun  8 16:27:49 2012.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#CALC_XTOMOBR_DATA">CALC_XTOMOBR_DATA</A>
<LI><A HREF="#CALC_XTOMOCORE_ASYMEMISS_DATA">CALC_XTOMOCORE_ASYMEMISS_DATA</A>
<LI><A HREF="#CALC_XTOMOCORE_EMISS_DATA">CALC_XTOMOCORE_EMISS_DATA</A>
<LI><A HREF="#CALC_XTOMO_EMISS_DATA">CALC_XTOMO_EMISS_DATA</A>
<LI><A HREF="#GENPOS">GENPOS</A>
<LI><A HREF="#GENPOS_ALIGN2XYZ">GENPOS_ALIGN2XYZ</A>
<LI><A HREF="#GENPOS_ALIGN_ROT">GENPOS_ALIGN_ROT</A>
<LI><A HREF="#GENPOS_COEFS2PROFILE">GENPOS_COEFS2PROFILE</A>
<LI><A HREF="#GENPOS_CYL2TOK">GENPOS_CYL2TOK</A>
<LI><A HREF="#GENPOS_DBLXYZ2TOK">GENPOS_DBLXYZ2TOK</A>
<LI><A HREF="#GENPOS_DET2U">GENPOS_DET2U</A>
<LI><A HREF="#GENPOS_DET2XYZ">GENPOS_DET2XYZ</A>
<LI><A HREF="#GENPOS_EMISS_INVERT">GENPOS_EMISS_INVERT</A>
<LI><A HREF="#GENPOS_GPV2COEF_MATRIX">GENPOS_GPV2COEF_MATRIX</A>
<LI><A HREF="#GENPOS_GPV2CONTOUR">GENPOS_GPV2CONTOUR</A>
<LI><A HREF="#GENPOS_GPV2PSITH">GENPOS_GPV2PSITH</A>
<LI><A HREF="#GENPOS_GPV2VOXEL_MATRIX">GENPOS_GPV2VOXEL_MATRIX</A>
<LI><A HREF="#GENPOS_GRID">GENPOS_GRID</A>
<LI><A HREF="#GENPOS_GRID2CENT">GENPOS_GRID2CENT</A>
<LI><A HREF="#GENPOS_GRID2GR">GENPOS_GRID2GR</A>
<LI><A HREF="#GENPOS_GRID2RMID">GENPOS_GRID2RMID</A>
<LI><A HREF="#GENPOS_GRID_BFIELD">GENPOS_GRID_BFIELD</A>
<LI><A HREF="#GENPOS_GRID_INVESSEL">GENPOS_GRID_INVESSEL</A>
<LI><A HREF="#GENPOS_GRID_SPHERE">GENPOS_GRID_SPHERE</A>
<LI><A HREF="#GENPOS_INFO2ALIGN">GENPOS_INFO2ALIGN</A>
<LI><A HREF="#GENPOS_INVERT_POS">GENPOS_INVERT_POS</A>
<LI><A HREF="#GENPOS_LHAT">GENPOS_LHAT</A>
<LI><A HREF="#GENPOS_LINE_BR">GENPOS_LINE_BR</A>
<LI><A HREF="#GENPOS_PLANAR2GPV">GENPOS_PLANAR2GPV</A>
<LI><A HREF="#GENPOS_PLANAR2POS">GENPOS_PLANAR2POS</A>
<LI><A HREF="#GENPOS_PLANAR2UPOS">GENPOS_PLANAR2UPOS</A>
<LI><A HREF="#GENPOS_PLANAR_INFO">GENPOS_PLANAR_INFO</A>
<LI><A HREF="#GENPOS_POLOIDALPOS2RT">GENPOS_POLOIDALPOS2RT</A>
<LI><A HREF="#GENPOS_POS2RMIDTANG">GENPOS_POS2RMIDTANG</A>
<LI><A HREF="#GENPOS_POS2VOXEL_MATRIX">GENPOS_POS2VOXEL_MATRIX</A>
<LI><A HREF="#GENPOS_POS_REFORM">GENPOS_POS_REFORM</A>
<LI><A HREF="#GENPOS_PROFILE_INVERT:">GENPOS_PROFILE_INVERT:</A>
<LI><A HREF="#GENPOS_ROT_MATRIX">GENPOS_ROT_MATRIX</A>
<LI><A HREF="#GENPOS_RZ2PSITH">GENPOS_RZ2PSITH</A>
<LI><A HREF="#GENPOS_SPHERE">GENPOS_SPHERE</A>
<LI><A HREF="#GENPOS_SPHERE_UPOS">GENPOS_SPHERE_UPOS</A>
<LI><A HREF="#GENPOS_SPHERICAL2POS">GENPOS_SPHERICAL2POS</A>
<LI><A HREF="#GENPOS_SPHERICAL2QUADCURVE">GENPOS_SPHERICAL2QUADCURVE</A>
<LI><A HREF="#GENPOS_SPHERICAL2UPOS">GENPOS_SPHERICAL2UPOS</A>
<LI><A HREF="#GENPOS_SPHERICAL_INFO">GENPOS_SPHERICAL_INFO</A>
<LI><A HREF="#GENPOS_SPHERICAL_REFL">GENPOS_SPHERICAL_REFL</A>
<LI><A HREF="#GENPOS_UPOS">GENPOS_UPOS</A>
<LI><A HREF="#GENPOS_VOL_COEFS">GENPOS_VOL_COEFS</A>
<LI><A HREF="#GENPOS_XYZ2ALIGN">GENPOS_XYZ2ALIGN</A>
<LI><A HREF="#GENPOS_XYZ2TOK">GENPOS_XYZ2TOK</A>
<LI><A HREF="#GRID_VES">GRID_VES</A>
<LI><A HREF="#LINE_PLANE_INT">LINE_PLANE_INT</A>
<LI><A HREF="#XRAY_TOMO_INFO">XRAY_TOMO_INFO</A>
<LI><A HREF="#XRAY_TOMO_POS">XRAY_TOMO_POS</A>
<LI><A HREF="#XTOMO_CORE_WRITE2TREE">XTOMO_CORE_WRITE2TREE</A>
<LI><A HREF="#XTOMO_GET_GOOD">XTOMO_GET_GOOD</A>
<LI><A HREF="#XTOMO_WRITE2TREE">XTOMO_WRITE2TREE</A>
<LI><A HREF="#_GENPOS">_GENPOS</A>
<LI><A HREF="#_TUTORIAL  - CREATING A VOLUME WEIGHTING VECTOR">
_TUTORIAL  - CREATING A VOLUME WEIGHTING VECTOR</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="CALC_XTOMOBR_DATA">
<H2>CALC_XTOMOBR_DATA</H2></A>
<A HREF="#CALC_XTOMOCORE_ASYMEMISS_DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	CALC_XTOMOBR_DATA

PURPOSE:
	This procedure loads brightness data from the XTOMO tree, time averages and forms it into a 2D array.

CALLING SEQUENCE

	CALC_XTOMOBR_DATA,shot,array,br,ch,t

INPUTS:
	shot:	LONG shot number
	array:	INT array number [1,2,3,4]
	
OPTIONAL INPUTS:
	del_i	INT number of time points to average over DEFAULT = 5 (50 kHz-> 10 kHz)
	good:	INTARR [n_ch] of 1's and 0's to toggle channels DEFAULT: good from XTOMO_GET_GOOD

KEYWORD PARAMETERS:
	rt:	/rt fills ch with rtang values instead of channel numbers

OUTPUTS:
	br:	FLTARR [n_ch, n_time] of the brightness [W/m^2] 
	ch:	INTARR [n_ch] of the channel number (not really useful) (see optional output)
	t:	FLTARR [n_time] of the time points

OPTIONAL OUTPUTS:
	ch:	FLTARR [n_ch,n_time] of the midplane "tangency radius" found by tracing the line of
			sight through the flux surfaces.  Uses GENPOS_POS2RMIDTANG.

PROCEDURE:
	Data is loaded from the \XTOMO::TOP.SIGNALS nodes and the etendue is calculated from XRAY_TOMO_POS.
	Background subtraction is done for each channel seperately using an average from the first point to
	the point where t=-20 ms.  The data is averaged over DEL_I time points and the new time point is
	the center.  DEL_I is forced to DEL_I-1 if it is an even number.

MODIFICATION HISTORY:
	Written by:	ML Reinke - 12/07
	1-17-08		ML Reinke - added the rt keyword which fills CH with RTANG values
	7-23-08:	ML Reinke - included the shot optional input in the call to XRAY_TOMO_POS
	7-31-08:	ML Reinke - included the shot optional input in the call to XRAY_GET_GOOD
				    if timing data is not consistent across array then interpolate 
				    to finer time grid (bad for fast events)

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="CALC_XTOMOCORE_ASYMEMISS_DATA">
<H2>CALC_XTOMOCORE_ASYMEMISS_DATA</H2></A>
<A HREF="#CALC_XTOMOBR_DATA">[Previous Routine]</A>
<A HREF="#CALC_XTOMOCORE_EMISS_DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	CALC_XTOMOCORE_ASYMEMISS_DATA

MODIFICATION HISTORY:
	4/6/11		M.L. Reinke - allowed the inclusion of the m=2 cosine term
	6/18/11		M.L. Reinke - added the ETREE optional input to allow for alternate EFIT trees
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="CALC_XTOMOCORE_EMISS_DATA">
<H2>CALC_XTOMOCORE_EMISS_DATA</H2></A>
<A HREF="#CALC_XTOMOCORE_ASYMEMISS_DATA">[Previous Routine]</A>
<A HREF="#CALC_XTOMO_EMISS_DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	CALC_XTOMOCORE_EMISS_DATA
	
PURPOSE:
	This procedure calculates the emissivity profile for the core xray tomography system assuming flux
	surface symmetry.  Deviations seen on the BRCHK are useful for observing in/out and up/down asymmetries
	GENPOS_POS2VOXEL_MATRIX is used to generate the spatial weightings and GENPOS_PROFILE_INVERT is used to 
	invert the data.

INPUTS:
	shot:		LONG 	shot number

OPTIONAL INPUTS:
	del_i:		INT	used in call to CALC_XTOMOBR_DATA
	good:		INTARR	[76] of 1's and 0's for operational channels DEFAULT calls XTOMO_GET_GOOD for array [1,3]
	eps:		FLT	of the smoothing weighting factor DEFAULT = 0.75
	eta:		FLT 	of the edge zero weighting factor DEFAULT = 1.0
	n_rho:		INT	number of rhopts DEFAULT = 30
	rho_vec:	FLTARR	of rho values to use for inversion (see PROCEDURE for array specific DEFAULTS)
	n_s:		INT	number of points to divide line of sight into for GENPOS_POS2VOXEL_MATRIX
	tr:		FLTARR 	[t_low,t_high] of the EFIT subset data to do the inversion
	
KEYWORD PARAMETERS:
	array2		/array2 will use array2 in calculated the emissivity profile, brightness vector 1,3,2
	array5		/array5 will use array5 in calculated the emissivity profile, brightness vector 1,3,5

OUTPUTS:
	emiss:		FLTARR	[n_rho,n_time] of the x-ray emissivity [W/m^3]
	rho:		FLTARR	[n_rho] of the rho values for the emissivity
	time:		FLTARR	[n_time] of the time points [sec]
	brchk:		FLTARR	[n_good,n_time] of the brightnesses calculated from the emissivity [W/m^2]

OPTIONAL OUTPUTS:
	rmaj:		FLTARR	[n_rho,n_time] of the outboard major radii of the rho values [m]
	bright:		FLTARR 	[n_good,n_time] of the brightness [W/m^2] DEFAULT calls CALC_XTOMOBR_DATA
	ch:		INTARR	[n_good] of channel numbers [0-76] of the good channels
	etree:		STRING	of the EFIT tree to use for inversion [DEFAULT: ANALYSIS]

PROCEDURE:
	CALC_XTOMOBR_DATA is used to load the data and a 76 channel [array_1,array_3] super array is formed (114 if /array2 or /array5)
	GENPOS_POS2VOXEL_MATRIX is used to calculated the weighting matrix using its default rho_vec with n_rho as defined above.
	The voxel matrix is run on the EFIT time base (or subset if tr is used) and then interpolated for use with the much faster x-ray data.
	GENPOS_PROFILE_INVERT is used to do the inversion.

MODFICATION HISTORY:
	Written by:	ML Reinke - 1/31/08 (adapated from CALC_XTOMO_EMISS_DATA)
	2/28/08:	ML Reinke - Fixed a bug that would mix up etendues if good was not the default.
	1/27/10:	ML Reinke - Fixed a bug so that if GOOD is sent to it, it will break it up
				    and send it to CALC_XTOMOBR_DATA
	6/18/11		M.L. Reinke - added the ETREE optional input to allow for alternate EFIT trees
	1/10/12		ML Reinke - added the ability to use array5 keyword
	5/30/12		M.L. Reinke - fixed a bug that caused inv_matrix to be held constant over inversions that was put in during the /fast update
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="CALC_XTOMO_EMISS_DATA">
<H2>CALC_XTOMO_EMISS_DATA</H2></A>
<A HREF="#CALC_XTOMOCORE_EMISS_DATA">[Previous Routine]</A>
<A HREF="#GENPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	CALC_XTOMO_EMISS_DATA
	
PURPOSE:
	This procedure calculates the emissivity profiles for the edge xray tomography system assuming flux
	surface symmetry.  GENPOS_POS2VOXEL_MATRIX is used to generate the spatial weightings and
	GENPOS_PROFILE_INVERT is used to invert the data.

INPUTS:
	shot:		LONG 	shot number
	array:		INT	edge array number [2,4]

OPTIONAL INPUTS:
	bright:		FLTARR 	[n_ch,n_t] of the brightness [W/m^2] DEFAULT calls CALC_XTOMOBR_DATA
	t:		FLTARR	[n_t] of the time points [sec] DEFAULT calls CALC_XTOMOBR_DATA
	del_i:		INT	used in call to CALC_XTOMOBR_DATA
	good:		INTARR	of 1's and 0's for operational channels DEFAULT calls XTOMO_GET_GOOD
	eps:		FLT	of the smoothing weighting factor DEFAULT = 1.0
	eta:		FLT 	of the edge zero weighting factor DEFAULT = 1.0
	n_rho:		INT	number of rhopts (final data will be n_rho-2) DEFAULT = 30
	rho_vec:	FLTARR	of rho values to use for inversion (see PROCEDURE for array specific DEFAULTS)
	n_s:		INT	number of points to divide line of sight into for GENPOS_POS2VOXEL_MATRIX
	
OUTPUTS:
	emiss:		FLTARR	[n_rho-2,n_time] of the x-ray emissivity [W/m^3]
	rho:		FLTARR	[n_rho-2] of the rho values for the emissivity
	time:		FLTARR	[n_time] of the time points [sec]
	brchk:		FLTARR	[n_good,n_time] of the brightnesses calculated from the emissivity [W/m^2]

OPTIONAL OUTPUTS:
	rmaj:		FLTARR	[n_rho-2,n_time] of the outboard major radii of the rho values [m]
	
	If unassigned variables are used for bright,ch and t then they become optional outputs.

PROCEDURE:
	If the brightness data is not input via the optional inputs than CALC_XTOMOBR_DATA is used to load the data.
	GENPOS_POS2VOXEL_MATRIX is used to calculated the weighting matrix using rho_vec specific to each array:
		2 : rho_vec=make(0.88,1.05,n_rho)
		4 : rho_vec=make(0.86,1.05,n_rho)
	The voxel matrix is run on the EFIT time base and then interpolated for use with the much faster x-ray data.
	The bad channels identified by GOOD are removed from bright and voxel and the brightness is truncated to the EFIT
	time window.  GENPOS_PROFILE_INVERT is used to do the inversion.

MODFICATION HISTORY:
	Written by:	ML Reinke - 1/22/08

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS">
<H2>GENPOS</H2></A>
<A HREF="#CALC_XTOMO_EMISS_DATA">[Previous Routine]</A>
<A HREF="#GENPOS_ALIGN2XYZ">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS

PURPOSE:
	This function calls several lower level functions to calculate,from user input, 
	a set of position vectors ([ro,zo,rt,psi]) that can be used in other GENIE programs.

CALLING SEQUENCE
	result=GENPOS(ap_vec,ap_rot,x0,x1,x2,det_pos)
	
INPUTS:
	ap_vec: 	FLTARR [ro, 0.0, zo] where ro and zo is the aperture position
	ap_rot:		FLTARR [alpha,beta,gamma] set of orientation angles of the aperture [in radians]
	x0:
	x1:		x3 FLTARR locations of the detector's fiducial points in aperture coordinates.
	x2:
	det_pos:	FLTARR [xi, zeta] x m where m is the number of points in the deteector plane
				for which GENPOS will cacluate position vectors

OPTIONAL INPUTS:
	a_det:		FLT area of detector [DEFAULT = 1.0]
	a_det:		FLTARR [xi zeta] (width,height) of the detector
	a_ap:		FLT area of aperature [DEFAULT = 1.0]
	a_ap:		FLT [y,z] (width, height) of the aperature.  Circle is defined by [rad, -1.0]
	
KEYWORD PARAMETERS:
	debug:		/debug stops before the RETURN statements

OUTPUTS:
	result:		FLTARR [ro,zo,rt,psi] x m position vectors

OPTIONAL OUTPUTS:
	bigXYZ_vec: 	FLTARR [X,Y,Z] vector of points in the XYZ system (tokamak)
	cyl_vec:	FLTARR [R,phi,Z] points in R-PSI-Z (tokamak cylindrical)
	xyz_vec:	FLTARR [x,y,z] vector of points in the xyz system (aperture)
	etendue:	FLTARR [n] of etendue values for the det_pos and x0,x1,x2.  If optional inputs a_det
				and a_ap are not input, this is per unit aperature and detector area.
	det_cos:	FLTARR [n] of the n_hat dotted into xyz_hat. This is the cosine of the angle of incidence of the ray onto
				the detector.  Useful for angular dependent filter transmissions at detector
	det_cos:	FLTARR [n] of the x_hat dotted into xyz_hat. This is the cosine of the angle of incidence of the ray onto
				through the aperture.  Useful for angular dependent filter transmissions at aperature

RESTRICTIONS:
	This function requires MLR_FUNCTIONS and other functions in GENPOS.PRO

PROCEDURE:
	See ML Reinke's "General Equations for Radiometry in Tokamak Plasmas" for an in-depth
	descriptions of the analysis that is performed in this and other GENPOS functions.

	GENPOS was formely used to find field of view bounds, but this functionality has been removed since 
	GENPOS_VOL_COEFS has been developed to do the job more accurately.

	The POS vector is found using GENPOS_XYZ2TOK and both points are checked to see if psi is in bounds.  If not, it is
	corrected and the pos vector is sent to GENPOS_INVERT_POS to form the equivilent line of sight.

MODIFICATION HISTORY:
	Written by: 	ML Reinke 4-17-06
	5-18-06:	ML Reinke - Overhaulled to included the field of view position vectors
	8-28-06:	ML Reinke - Overhaulded removing full,fovpos type crap since it's covered by
                                   GENPOS_VOL_COEFS.  Also fixed the -!pi/2 < psi < !pi/2 error using GENPOS_INVERT_POS
	12-2-08:	ML Reinke - Added links to the ap_cos and det_cos optional outputs from GENPOS_DET2U

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_ALIGN2XYZ">
<H2>GENPOS_ALIGN2XYZ</H2></A>
<A HREF="#GENPOS">[Previous Routine]</A>
<A HREF="#GENPOS_ALIGN_ROT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_ALIGN2XYZ

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_ALIGN_ROT">
<H2>GENPOS_ALIGN_ROT</H2></A>
<A HREF="#GENPOS_ALIGN2XYZ">[Previous Routine]</A>
<A HREF="#GENPOS_COEFS2PROFILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_ALIGN_ROT

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_COEFS2PROFILE">
<H2>GENPOS_COEFS2PROFILE</H2></A>
<A HREF="#GENPOS_ALIGN_ROT">[Previous Routine]</A>
<A HREF="#GENPOS_CYL2TOK">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_COEFS2PROFILE

PURPOSE:
	This function converts a set of coefficients determined by programs like GENSPEC_INVERT_MOMENTS into
	profiles in normalized major radius, rho.

CALLING SEQUENCE:
	result=GENPOS_COEFS2PROFILE(coefs)
	
INPUTS:
	coefs:		FLTARR of size order x n_time of the coefficents to a polynomial [DEFAULT] or orthogonal
				bessel function expansion

OPTIONAL INPUTS:
	nr:		FLT of number of points on which to create profile DEFAULT: 50

KEYWORD PARAMETERS:
	bessel:		/bessel uses an expansion of even orthogonal bessel functions (see PROCEDURE)

OUTPUTS:
	result:		FLTARR of size nr x n_time of the profile.

PROCEDURE:
	Let a = coefs,x=rho m=order-1 and result=y to simplify the explanation
	For the polynomial 		y=a[0]+0.0*x+a[1]*x^2+a[2]*x^3....+a[m]*x^(m+1)	
	For the bessel fucntion		y=a[0]*J_0(X_00*x)+a[1]*J_2(X_02*x)....+a[m]*J_(2*m)(X_0(2*m)*x)
	(X_ij are the zeros)

	These expansions both force the profiles to have zero derivitave on axis which must be true when
	flux surface symmetry is assumed.  The bessel function expansion forces the profile to be zero
	at rho=1 which will be valid for peaked or slightly hollow profiles.  For edge dominated profiles
	an alternative expansion will be necessary

MODIFICATION HISTORY:
	Written by:	ML Reinke: 8-21-06

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_CYL2TOK">
<H2>GENPOS_CYL2TOK</H2></A>
<A HREF="#GENPOS_COEFS2PROFILE">[Previous Routine]</A>
<A HREF="#GENPOS_DBLXYZ2TOK">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_CYL2TOK

PURPOSE:
	This function generates the tangency radius (R_t) and
	declination angle (psi) given two RZ positions and cosine of
	the angle between them

CALLING SEQUENCE:
	result=GENPOS_CYL2TOK(rz1,rz2,cosphi)

INPUTS:
	rz1:		FLTARR [r1,z1]
	rz2:		FLTARR [r2,z2]
	cosphi:		FLT cos(phi)

OUTPUTS:
	result:		FLTARR [R_t, psi]

PROCEDURE:
	This function uses equations (13) and (15) in Section 3.1 -
	Tokamak Coordinates.  Note that if R_2 > R_1 the psi returned
	will not be accurate.

MODIFICATION HISTORY:
	Written by:  	ML Reinke - June 2006
   	8-30-06:	ML Reinke - added an if statement for when cosphi approaches one, the
                                   singularity is avoided in computing r_tang
                                                      
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_DBLXYZ2TOK">
<H2>GENPOS_DBLXYZ2TOK</H2></A>
<A HREF="#GENPOS_CYL2TOK">[Previous Routine]</A>
<A HREF="#GENPOS_DET2U">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_DBLXYZ2TOK

PURPOSE:
	This function generates the tangency radius (R_t) and
	declination angle (psi) given two positions in the xyz
	(aperate) coordinate system and information about the aperture
	position and viewing direction

CALLING SEQUENCE:
	result=GENPOS_DBLXYZ2TOK(ap_vec,xyz1,xyz2,rot)

INPUTS:	
	ap_vec:		FLTARR [ro, 0.0, zo] where ro and zo is the aperture position
	xyz1:		FLTARR [x,y,z] location of point 1 in aperature coordinates
	xyz2:		FLTARR [x,y,z] location of point 2 in aperature coordinates
	rot: 		FLTARR rotation matrix generated using GENPOS_ROT_MATRIX

OUTPUTS:
	result:		FLTARR [R_t, psi]

OPTIONAL OUTPUTS:
	bigXYZ_vec:	FLTARR [2,3] where [i,*] is the XYZ vector of each point
	cyl_vec:	FLTARR [2,3] where [i,*] is the cylindrical vector of each point 

PROCEDURE:
	This function generates the XYZ positions of each point then
	forms the RZ positions and the cosphi and uses GENPOS_CYL2TOK
	to find R_t and psi.

MODFICATION HISTORY:
	Written by:	ML Reinke - June 2006

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_DET2U">
<H2>GENPOS_DET2U</H2></A>
<A HREF="#GENPOS_DBLXYZ2TOK">[Previous Routine]</A>
<A HREF="#GENPOS_DET2XYZ">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_DET2U

PURPOSE:
	This function calculates the etendue, U, given a detectors
	position and det/ap areas.

CALLING SEQUENCE:
	result=GENPOS_DET2U(x0,x1,x2,det_pos)

INPUTS:
	x0:
	x1:		x3 FLTARR locations of the detector's fiducial points in aperture coordinates.
	x2:
	det_pos:	FLTARR [2,n] where [*,i] are [xi,zeta] positions on the detector plane	

OPTIONAL INPUTS:
	a_det:		FLT of the detector area
	a_ap:		FLT of the aperture area

KEYWORD PARAMETERS:
	debug:	/debug stops the program before RETURN

OUTPUTS:
	result:		FLTARR of length n, with each element containing the exact etendue, including det/ap
			cosine terms.  If a_det and/or a_ap are not included then output is per unit detector
			and/or aperature area.

OPTIONAL OUTPUTS:
	det_cos:	FLTARR [n] of the n_hat dotted into xyz_hat. This is the cosine of the angle of incidence of the ray onto
				the detector.  Useful for angular dependent filter transmissions at detector
	det_cos:	FLTARR [n] of the x_hat dotted into xyz_hat. This is the cosine of the angle of incidence of the ray onto
				through the aperture.  Useful for angular dependent filter transmissions at aperature

PROCEDURE:
	The exact relation for etendue is calculated (see Section 3.2 'Aperture Coordinates') by finding the projection of the
	detector and aperture normals onto the line connecting the center of the aperature and detector.

MODIFICATION HISTORY:
	Written by:	ML Reinke - June 2006
	12/2/08:	ML Reinke - added det_cos and ap_cos optional output

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_DET2XYZ">
<H2>GENPOS_DET2XYZ</H2></A>
<A HREF="#GENPOS_DET2U">[Previous Routine]</A>
<A HREF="#GENPOS_EMISS_INVERT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_DET2XYZ

PURPOSE:
	This function transforms a position located on the detector
	plane (xi, zeta) to a position in the aperature coordinate
	system (xyz)

CALLING SEQUENCE:
	result=GENPOS_DET2XYZ(x0,x1,x2,det_pos)

INPUTS:
	x0:
	x1:		x3 FLTARR locations of the detector's fiducial points in aperture coordinates.
	x2:
	det_pos:	FLTARR [2,n] where [*,i] are [xi,zeta] positions on the detector plane

KEYWORD PARAMETERS:
	debug:	/debug stops the program before RETURN

OUTPUTS:
	result:		FLTARR [3,n] where [*,i] are [x,y,z] positions in the aperature coordinate system

PROCEDURE
	The detector coordinates are located by x0,x1,x2 where x0->x1
	is in the zeta direction and x0->x2 is in the xi direction.
	The detector plane is define by xi and zeta and xi cross zeta
	is the detector normal which points towards the aperature (ie
	n_hat dot x_hat is > 0).  See section 3.2 'Aperture Coordinates'

MODIFICATION HISTORY:
	Written by:	ML Reinke, June 2006

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_EMISS_INVERT">
<H2>GENPOS_EMISS_INVERT</H2></A>
<A HREF="#GENPOS_DET2XYZ">[Previous Routine]</A>
<A HREF="#GENPOS_GPV2COEF_MATRIX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_EMISS_INVERT

PURPOSE:
	This function is an upper level function to calculate the emissivity profile from an array of power deposited
	and and GPV values.

CALLING SEQUENCE:
	result=GENPOS_EMISS_INVERT(power,gpv,shot,time,ves_cent)

INPUTS:
	power:		FLTARR 	[n_ch, n_time] of power deposited (ph/s or Watts) NOTE: this is NOT brightness (W/m^2)
	gpv:		FLTARR 	[n_ch, n_pnts] of volume weightings for each channel [m^3] (see GENPOS_VOL_COEFS)
	shot:		LONG	shot number
	time:		FLTARR	[n_time] of time scale of powers [seconds]
	ves_cent	STRUC	of information for the voxel gridding for which gpv was calculated.
	
OPTIONAL INPUTS:
	good:		INTARR	[n_ch] with 1's (use) or 0's (do not use) indicating which channels to use during the inversion
	rhopts:		FLTARR	[n_grid, n_time] of the rho values corresponding to the (R,Z) grid points.  This will be calculated
				by GENSPEC_MATRIX_INVERT but is an optional output that can be reused on different spectral lines to
				save computation time.
	n_rho:		INT	number of points from minimum < rho < 1.0 (inclusive) to be used in inversion DEFAULT: 25
	rho_vec:	FLTARR 	the actually rho points to be used DEFAULT: not used35
	eta:		FLT	edge zero weighting factor DEFAULT: 0.0
	eps:		FLT	 profile smoothing factor. DEFAULT: 1.0

KEYWORD PARAMETERS:
	nofirst:	/nofirst prevents the matrix inversion from weighting the profile so that it has zero derivative at rho=0
	debug:		/debug stops the code in various places and just before the RETURN statement
	quiet:		/quiet suppresses terminal messages displaying computation times of various procedures

OUTPUTS:
	result:		STRUC	containing the kinetic profiles and their moment profile checks
			*.rho		FLTARR 	[n_rho] of the rho values at which each profile has been calculated
			*.time		FLTARR 	[n_time] of the time points (copy of time input for convience)
			*.emiss 	FLTARR 	[n_rho, n_time] of the emissivity "power"/m^3 [ph/s/m^3 or W/m^3]
			*.ch		INTARR 	[n_ch] of only the GOOD channels used in the inversion
			*.brchk		FLTARR 	[3, n_ch, n_time] of the moments calculated from the calculated profiles.  This can be
						be used to check the quality of the output versus the input data.

PROCEDURE:
	This program calculates the spatial weighting matrices using GENPOS_GPV2VOXEL_MATRIX and then inverts them using 
	GENPOS_PROFILE_INVERT.  The eps value at each time point are weighted to the max value of
	the voxel matrix.  For example, the GENPOS_PROFILE_INVERT eps at each time point i is: 
		
		double(eps_em*(max(voxel[*,*,i]))^2)

RESTRICTIONS:
	Use GENIE_INI.bat to compile the GENPOS functions in the correct order.  You should know what you're doing before
	using this function. 

MODFICATION HISTORY:
	Written by:	ML Reinke - 8/21/07

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GPV2COEF_MATRIX">
<H2>GENPOS_GPV2COEF_MATRIX</H2></A>
<A HREF="#GENPOS_EMISS_INVERT">[Previous Routine]</A>
<A HREF="#GENPOS_GPV2CONTOUR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GPV2COEF_MATRIX

PURPOSE:
	This function is the rosetta stone!  It takes in a set of volume coefs (output of GENPOS_VOL_COEFS) and
	a set of rho values corresponding to these (R,Z) points (output of GENPOS_GRID2RMID) and generates
	the coeffcient matrix to be used in a linear least squares fit to a radial emissivity profile.  Since this process assumes
	flux surface symmetry, the matrix is generated to force the slope at rho=0 to be zero.

CALLING SEQUENCE:
	result=GENPOS_GPV2COEF_MATRIX(gpv,rhopts,order)

INPUTS:
	gpv:	FLTARR 	n x m where n is the number of detectors and m is the number of pixels.  These are the volume coefficents
				generated using GENPOS_VOL_COEFS (or GENPOS_PLANAR2POS if a planar array was used) [meters^3]
	rhopts:	FLTARR	m x t where t is the number of time points.  These are normalized radius values that correspond to the m
				pixels and should be generated using GENPOS_GRID2RMID.
	order:	INT	order of the polynomial (DEFAULT) or bessel function expansion

KEYWORD PARAMETERS:
	bessel:		/bessel uses a bessel function of the first kind (BESELJ) as the basis function instead of a polynomial
	debug:		/debug stops the code before the return statement

OUTPUTS:
	result:	FLTARR n x order x t where [*,*,i] is the matrix, A, to be used in the least squares inversion of (A*x=b) where
			b is the vector of length n and x is the vector of length order and are the coeffcients of the
			See http://en.wikipedia.org/wiki/Linear_least_squares for a brief overview and Numerical Recipes for
			something more indepth.

PROCEDUE:
	There will be a note in 'General Equations for Radiometry in Tokamak Plasmas' regarding how the expansion works but
	for now just talk to ML Reinke directly if you've got questions on the method.

	The expansion for poly is f=a_0+a_1*x^2+x_2*x^3 so that when using POLY on the coefs found, you need to use
	coefs=[coefs[0],0.0,coefs[1:n(coefs)]].  This means that the expansion has x^order terms.  For the
	Bessel expansion, only even Bessels are used to fix the slope at rho=0 to be zero.  Also, the Bessel expansion is done in
	orthogonal functions so f=a_0*J_0(xi_00*rho)+a_1*J_2(xi_20*rho)+a_2*J_4*(xi_40*rho).... in order to force emiss to zero at rho=1

MODIFICATION HISTORY:
	Written by:	ML Reinke 8-1-06
	8-4-06:		ML Reinke - adjusted bessel/poly expansion so that there slope at rho=0 is zero.
	6-7-07:		ML Reinke - made it so the WHERE command selects points where rhopts > 0 and GPV > 0

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GPV2CONTOUR">
<H2>GENPOS_GPV2CONTOUR</H2></A>
<A HREF="#GENPOS_GPV2COEF_MATRIX">[Previous Routine]</A>
<A HREF="#GENPOS_GPV2PSITH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GPV2CONTOUR

PURPOSE:
	This procedure is used to visualize a voxel weighting by making a contour plot in (R,Z) space.

CALLING SEQUENCE:
	GENPOS_GPV2CONTOUR,gpv,ves_cent

INPUTS:
;	gpv:		FLTARR [n_det,n_vox] of voxel weightings generated using GENPOS_VOL_COEFS
	ves_cent	STRUC of the voxel points created using GENPOS_GRID or GRID_VES with /center
	
OPTIONAL INPUTS:
	det:		INTARR of the dector number(s) to select gpv[det,*] DEFAULT: 0
	shot:		LONG shot number for EFIT reconstructions DEFAULT: 1050426022
	time:		FLT time point for EFIT reconstructions DEFFAULT: 1.0
	nlevels:	INT number of levels for the contour plot DEFAULT: 20
	cct:		INT color table for the contour plot DEFAULT: 39
	pos:		FLTARR [Ro,Zo,Rt,Psi] of the detector(s) that is being visualized.  If included a line of sight 
			will be plotted over the volume contour plot. For multiple detectors insert entire 2D POS array
	win:		INT of the window number to send plot.  DEFAULT: see VESSEL_PLOT in MLR_FUNCTIONS
	
KEYWORD PARAMETERS:
	invessel:	/invessel will prevent the program from plotting points that are outside the PFC boundary
			by calling GENPOS_GRID_INVESSEL
	ps:		/ps makes formatting changes and should be used when plotting to a postscript
	edge:		/edge is sent to VESSEL_PLOT
	div:		/div is sent to VESSEL_PLOT
	fsplot:		/fsplot will plot the flux surfaces for the shot and time using FS_PLOT in MLR_FUNCTIONS
	
OUTPUTS:
	All outputs are made to the currently selected graphics device.

RESTRICTIONS:
	GENPOS_GPV2CONTOUR was intially intended to check the contour plots of the output of GENPOS_PLANAR2GPV.  This means the
	data input likes to be formatted in a [n_det,n_vox].  The output of GENPOS_VOL_COEFS will be a 1D array of length n_vox.
	To use the contour plotting, make sure the optional input det=0 is used.
	
MODIFICATION HISTORY:
	Written by: 	ML Reinke - Spring 2007
       6-20-07:	ML Reinke - added the ability to plot multiple detectors  on a single cross-secion
	7-14-07:	ML Reinke - added the ability to plot multiple POS lines when multiple detectors are plotted.

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_utility.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GPV2PSITH">
<H2>GENPOS_GPV2PSITH</H2></A>
<A HREF="#GENPOS_GPV2CONTOUR">[Previous Routine]</A>
<A HREF="#GENPOS_GPV2VOXEL_MATRIX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GPV2PSITH

PURPOSE:
	This procedure is used to visualize the voxel weighting of a multidetector GPV array
	in (psi,theta) space.

CALLING SEQUENCE:
	GENPOS_GPV2PSITH,gpv,ves_cent

INPUTS:
	gpv:		FLTARR [n_det,n_pix] of voxel weightings generated using GENPOS_VOL_COEFS
	ves_cent	STRUC of the voxel points created using GENPOS_GRID or GRID_VES with /center
	
OPTIONAL INPUTS:
	det:		INT of the dector number to select gpv[det,*] DEFAULT: 10
	shot:		LONG shot number for EFIT reconstructions DEFAULT: 1050426022
	time:		FLT time point for EFIT reconstructions DEFFAULT: 1.0
	nlevels:	INT number of levels for the contour plot DEFAULT: 20
	cct:		INT color table for the contour plot DEFAULT: 39

KEYWORD PARAMETERS:
	ps:		/ps should be used if a postscript is to be generated to adjust plot formatting

OUTPUTS:
	All outputs are to the currently selected graphics device.

MODIFICATION HISTORY:
	Written by:	ML Reinke - Spring 2007

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_utility.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GPV2VOXEL_MATRIX">
<H2>GENPOS_GPV2VOXEL_MATRIX</H2></A>
<A HREF="#GENPOS_GPV2PSITH">[Previous Routine]</A>
<A HREF="#GENPOS_GRID">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GPV2VOXEL_MATRIX

PURPOSE
	This function will take a set of GPVs and the rho values of their locations and
	turn it into a voxel weighting matrix for emissivitiy profile inversion (think L matrix for Abel inversion)

CALLING SEQUENCE
	result=GENPOS_GPV2VOXEL_MATRIX(gpv, rhopts)

INPUTS:
	gpv		FLTARR [n_ch, n_pts] of the volume weightings generated using GENPOS_VOL_COEFS
	rhophts		FLTARR [n_pts,n_time] of the rho locations of the (R,Z) points that locate each GPV at each time point
	
OPTIONAL INPUTS:
	n_rho:		INT number of points from 0.0 -> 1.0 (inclusive) for the result
	rho_min:	FLT instead of 0.0 the rho values are taken from some input, minimum rho
	rho_vec:	FLTARR [n_rho] of the rho points that each column of the result

OUTPUTS
	result:		FLTARR [n_ch, n_rho, n_time] of the voxel weightings for each channel at each rho to be used in profile inversion

OPTIONAL OUTPUTS:
	rho_vec:	FLTARR if set to an unnamed variable it will be filled with the rho.


MODIFIATION HISTORY:
	Written by:	ML Reinke 6/11/07
	7-12-07:	ML Reinke - fixed a WHERE bug that would crash if no weighting in the plasma was found
       7-17-07:	ML Reinke - allowed 2D rhopts so that multiple time slices can be calculated
	8-02-07:	ML Reinke - added the rho_min optional input
	1-03-08:	ML Reinke - modified the voxel filling to interpolate between two nearest bins instead of placing all the
                                   gpv in the nearest bin
	1-04-08:	ML Reinke - fixed a bug in the previous mod that would cause a bin to goto NAN if mapped rho value EQ a bin rho

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GRID">
<H2>GENPOS_GRID</H2></A>
<A HREF="#GENPOS_GPV2VOXEL_MATRIX">[Previous Routine]</A>
<A HREF="#GENPOS_GRID2CENT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GRID

PURPOSE:
	This function creates a regular a grid of points for use with
	GENPOS_UPOS and GENPOS_VOL_COEFS.

CALLING SEQUENCE:
	result=GENPOS_GRID(delx,dely,n)

INPUTS:
	delx:	FLT extent in the horizontal direction
	dely:	FLT extend in the vertical direction
	n:	FLT number of rectangular grid locations (square spacing)
		FLTARR [nx,ny] points in the [hor,ver] directions

OPTIONAL INPUTS:
	xo:	FLT x-position of the grid center
	yo:	FLT y=position of the grid center

KEYWORD_PARAMETERS:
	center:	/gives points that are at the center of the grid points instead of their boundaries.
	circle: /circle makes r=delx/2.0 and spacing is square with nx number of points in both directions.
	debug:	/debug stops the program before RETURN

OUTPUTS:
	result: STRUC containing the grid points and the areas
		*.pnts FLTARR [2,(nx+1)*(ny+1)] of points that bound a grid location
		*.area FLT of the areas of grid elements
		*.n    FLTARR [nx,ny] of input

	(note that *.pnts is [2, nx*ny] if /center is used)

RESTRICTIONS:
	To use /circle you must have GENIE_LINE compiled since
	LINE_INLCFS is use.  Also /circle isn't perfect yet.

	This functions requires MLR_FUNCTIONS as well.

EXAMPLE:
	Using /center, GENPOS_GRID can be used to make grids that are pixel boundaries and
	grids of points that are centers of those pixels.

	out=GENPOS_GRID(1.0,2.0,[5,10])
	out_c=GENPOS_GRID(1.0,2.0,[5,10],/center)
	plot,out.pnts[0,*],out.pnts[1,*],psym=5,xr=[-0.75,0.75],/xsty,yr=[-1.25,1.25],/ysty
	oplot,out_c.pnts[0,*],out_c.pnts[1,*],psym=4

	This will plot triangles that are the locations of the grid
	element boundaries and diamonds that are the centers of these
	pixels.  Both have *.area that are the same.

PROCEDURE:

	The orientation of the grid points is

	         DEFAULT				 /CENTER

      4 --------------------------              --------------------------              
	 |    |    |    |    |    |           3  |    |    |    |    |    |              
      3 --------------------------              --------------------------
        |    |    |    |    |    |           2  |    |    |    |    |    |              
  y   2 --------------------------              --------------------------
        |    |    |    |    |    |           1  |    |    |    |    |    |              
      1 --------------------------              --------------------------
        |    |    |    |    |    |           0  |    |    |    |    |    |              
      0 --------------------------              --------------------------
        0    1    2    3    4    5                 0    1    2    3    4    
	             x
      (4,4)-----------------------              --------------------------
	 |    |    |    |    |    |              |3,3 |7,7 |    |    |    |
      (3,3)-----------------------              --------------------------
        |    |    |    |    |    |              |2,2 |6,6 |    |    |    |
  y   (2,2)(7,7)------------------              --------------------------
        |    |    |    |    |    |              |1,1 |5,5 |    |    |    |
      (1,1)(6,6)------------------              --------------------------
        |    |    |    |    |    |              |0,0 |4,4 |    |    |    |
      (0,0)(5,5)------------------              --------------------------
       	             
	So to get the ygr and xgr vectors use:
		ygr=grid.pnts[1,0:grid.n[1]]
		xgr=grid.pnts[0,indgen(out.n[0]+1)*(out.n[1]+1)]

	If using a /center grid then
		ygr=grid.pnts[1,0:grid.n[1]-1]
		xgr=grid.pnts[0,indgen(out.n[0])*(out.n[1])]

MODIFICATION HISTORY:
	Written by: ML Reinke June 2006
	7-27-06:	ML Reinke - added the input n [#x, #y] to output structure for reasons of portability

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GRID2CENT">
<H2>GENPOS_GRID2CENT</H2></A>
<A HREF="#GENPOS_GRID">[Previous Routine]</A>
<A HREF="#GENPOS_GRID2GR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GRID2CENT
	
PURPOSE:
	This function converts a GENPOS_GRID structure that is used in GENPOS_VOL_COEFS into a GENPOS_GRID structure that
	was generated using the /center keyword.  A "centers" structure is what is used in the rest of GENPOS and this function
	can be used in GENPOS_VOL_COEFS and GENPOS_PLANAR2GPV to convert the ves_grid into ves_cent to store with the GPV and
	lhat data.

CALLING SEQUENCE:
	result=GENPOS_GRID2CENT(grid)

INPUTS:
	grid: 	STRUC containing the grid edge locations (see OUTPUT of GENPOS_GRID)

KEYWORD PARAMETERS:
	debug:	/debug stops the function before the RETURN statement

OUTPUTS:
	result:	STRUC containing the grid center locations (see OUTPUT of GENPOS_GRID using /center keyword)

MODFICIATION HISTORY:
	Written by:	ML Reinke - 8/8/07

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GRID2GR">
<H2>GENPOS_GRID2GR</H2></A>
<A HREF="#GENPOS_GRID2CENT">[Previous Routine]</A>
<A HREF="#GENPOS_GRID2RMID">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GRID2GR

PURPOSE:
	This procedure takes in a grid structure generated from
	GENPOS_GRID and then returns the 1D vectors of the xgrid and
	ygrid values.

CALLING SEQUENCE:
	GENPOS_GRID2GR,grid,xgr,ygr

INPUTS:
	grid:	STRUC from GENPOS_GRID (can be generated as default or using /center)

OUTPUTS:
	xgr:	FLTARR of the x-locations of the grids
		length = grid.n[0] if /center, grid.n[0]+1 if default
	ygr:	FLTARR of the y-location of the grids
		length = grid.n[1] if /center, grid.n[1]+1 if default

MODIFICATION HISTORY:
	Written by:	M.L. Reinke 10-21-06

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GRID2RMID">
<H2>GENPOS_GRID2RMID</H2></A>
<A HREF="#GENPOS_GRID2GR">[Previous Routine]</A>
<A HREF="#GENPOS_GRID_BFIELD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GRID2RMID

PURPOSE:
	This function takes a vessel grid and, using EFIT flux surfaces, creates a vector of points
	on the outboard midplane. 

CALLING SEQUENCE:
	result = GENPOS_GRID2RMID(grid,shot)

INPUTS:
	grid:		STRUC 	of grid points generated from GENPOS_GRID using /center
	shot:		LONINT 	shot number

OPTIONAL INPUTS:
	tpts:		FLTARR 	of time points that the output is generated for DEFAULT: all EFIT time points
	efit_times:	FLTARR 	of the the EFIT time points can be input to save on load time.  Otherwise LINE_GETTIMES 
				is uses to load the EFIT data.

KEYWORD PARAMETERS:
	sol:		/sol allows values outside the LCFS to be returned as their EFIT_RZ2RMID values and not = -1
	rho:		/rho returns the points as normalized radius, rho.
	debug:		/debug stops the code before the RETURN
	
OUTPUTS:
	result:		FLTARR 	n x t where n is the number of grid points (grid.n[0]*grid.n[1]) and t is
				the number of time points.  Each value of of the array is the return of
				EFIT_RZ2RMID for that (R,Z) point. Values outside of the LCFS = -1 (unless /sol is invoked)

RESTRICTIONS:
	This function uses EFIT_RZ2RMID.  In fact this is little more than a script that abuses the privledge that
	is...EFIT_RZ2RMID.  In fact, most of GENIE would not be possible without that wonderful script.

PROCEDURE:
	EFIT_RZ2RMID is used to find the locations of all the pixels. This channel map can be created once for each shot,
	and any number of views which use this gridding can use the same channel map.  Because only one EFIT_RZ2RMID call 
	is used, then even large grids (100 x 100) can be processed for an entire shot in less than a minute 
	on one of the Alcator workstations.


MODIFICATION HISTORY:
	Written by:	ML Reinke 7-27-06
	8-01-06:	ML Reinke - Changed output format to just send back the radius values (EFIT_RZ2RMID output)
	8-08-07:	ML Reinke - Added the /sol keyword

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GRID_BFIELD">
<H2>GENPOS_GRID_BFIELD</H2></A>
<A HREF="#GENPOS_GRID2RMID">[Previous Routine]</A>
<A HREF="#GENPOS_GRID_INVESSEL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GRID_BFIELD

PURPOSE:
	This function takes in an output of GENPOS_GRID or GRID_VES and finds the magnitudes of the
	magnetic field in cyldrical coordinates.  This is used in GENSPEC programs that need these
	values when invoking incompressibility for the velocity.

CALLING SEQUENCE:
	result=GENPOS_GRID_BFIELD(gridpts,shot)
	
INPUTS:
	gridpts:	STRUC that is the output of GENPOS_GRID or GRID_VES using /center
	shot:		LONG shot number

OPTIONAL INPUTS:
	t_pts:		FLTARR of time points to perform operations DEFAULT: EFIT time points

OUTPUTS:
	result:		STRUC of data relating to the magnetic field components at the grid points
			*.br		FLTARR [n_grid, n_time] radial component of the magnetic field [T]
			*.bphi 		FLTARR [n_grid, n_time] toroidal component of the magnetic field [T]
			*.bz		FLTARR [n_grid, n_time] veritical component of the magnetic field [T]
			*.psi_norm	FLTARR [n_grid, n_time] normalized psi values
			*.t_pts		FLTARR [n_time] time points [s]
			*.shot		LONG shot number

PROCEDURE:
	The radial and veritical field componenets are computed by EFIT_RZ2PSI.  The values of psi returned by that function
	are used, along with PSI0 and PSIBDY to computer psi_norm.  The toroidal field is calculated using the experimental
	toroidal field and assume the spatial variation is Bphi=Bt0*R0/R.  This ignores the diamagnetic term, but a comparison
	with Bt=F/R shows this is negligbable.  See BTOR_COMPARE for evidence.

MODIFICATION HISTORY:
	Written by: 	ML Reinke - 6/6/07

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GRID_INVESSEL">
<H2>GENPOS_GRID_INVESSEL</H2></A>
<A HREF="#GENPOS_GRID_BFIELD">[Previous Routine]</A>
<A HREF="#GENPOS_GRID_SPHERE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GRID_INVESSEL
	
PURPOSE:
	This function takes a vessel grid and outputs an INTARR describing whether each point on the grid
	is insides (1) or outside (0) of the vessel.  This way, grids can be truncated prior to inversion to remove
	pixels that would be outside the vessel.

CALLING SEQUENCE:
	result=GENPOS_GRID_INVESSEL(ves_grid)

INPUTS:
	ves_cent:	STRUC output of GENPOS_GRID that defines the vessel (use /center)
	
OPTIONAL INPUTS:
	del:		FLT if del is specified then LINE_VESSEL is run with /new at the given del.  Otherwise
				LINE_VESSEL is run with /load.

KEYWORD PARAMETERS:
	plot:		/plot will produce a plot of the vessel with filled in circles for the grid points that
				are inside the vessel and hollow circles for those outside.  This can be used
				to verify the grid has been properly truncated (suggested).  Grids larger
				than 3600 points switch to just plotting dots inside the vessel for clarity
	debug:		/debug stops the code before the RETURN command

OUTPUTS:
	result:		INTARR of length ves_grid.n[0]*ves_grid.n[1] that contains 1 if the pixel is inside the vessel
				and 0 if it is outside.  The order is that of ves_grid.pnts.

PROCEDURE:
	This function uses a tightly meshed contour of the vessel wall (NOT LIMITER) as the boundary points for
	LINE_INLCFS.  Since LINE_INLCFS was designed for boundaries that are convex to interior points, some hacks
	have been implimented to make it work with the divertor geometry.  It works pretty well, but since it's
	not gaurenteed, a /plot should be used when generating the output for a new grid meshing.
		
MODIFICATION HISTORY:
	Written by:	ML Reinke: 8-4-06
	10-26-06:	ML Reinke - updated so that it works for old/new divertor geometry and in the divertor itself.
	1-20-06:	ML Reinke - updated so that the /plot feature calls VESSEL_PLOT
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_GRID_SPHERE">
<H2>GENPOS_GRID_SPHERE</H2></A>
<A HREF="#GENPOS_GRID_INVESSEL">[Previous Routine]</A>
<A HREF="#GENPOS_INFO2ALIGN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_GRID_SPHERE

PURPOSE:
	This function is used to grid (centers) a spherical mirror in the xyz coordinate system.

CALLING SEQUENCE:
	result=GENPOS_GRID_SPHERE(info)

INPUTS:
	info	STRUC 	of info file

OPTIONAL INPUTS:
	ny	INT	of the number of grid points in the y-hat direction DEFAULT: 5	
	nz	INT	of the number of grid points in the z-hat direction DEFAULT: 5

KEYWORD PARAMETERS:
	debug	/debug will stop the program before the RETURN statement

OUTPUTS:
	result:	FLTARR [3,nz*ny] of the <x,y,z> points on the mirror [m]

OPTIONAL OUTPUS:
	dA	FLTARR	[nz*ny] of the area [m^2] of each grided element

PROCEDURE:
	This assumes that the center of the mirror is at the origin of the xyz coordinate system with the x-hat
	being along the mirror normal.

MODIFICATION HISTORY:
	Written by: 	M. L. Reinke 1/10
	8/20/10		M.L. Reinke - modified the rectangular gridder to use centers and calculate the area
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_INFO2ALIGN">
<H2>GENPOS_INFO2ALIGN</H2></A>
<A HREF="#GENPOS_GRID_SPHERE">[Previous Routine]</A>
<A HREF="#GENPOS_INVERT_POS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_INFO2ALIGN

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_INVERT_POS">
<H2>GENPOS_INVERT_POS</H2></A>
<A HREF="#GENPOS_INFO2ALIGN">[Previous Routine]</A>
<A HREF="#GENPOS_LHAT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_INVERT_POS
	
PURPOSE:
	This function takes in POS vectors who's psi values are outside of the -!pi/2 < psi < !pi/2 range
	where the functionality of GENPOS is defined and converts them to an equivlent POS vector looking
	throught the plasma in the opposite direction.

CALLING SEQUENCE:
	result=GENPOS_INVERT_POS(pos)
	
INPUTS:
	pos:	FLTARR of 4 x m where m is the number of pos vectors.

OPTIONAL INPUTS:
	rzbnd:	FLTARR of [r_min,r_max,abs(z)] of the plasma boundary.  See PROCEDURE for use.  DEFAULT: [0.44,1.0,0.5]

KEYWORD PARAMETERS:
	debug:	/debug stops the code before the RETURN statement

OUTPUTS:
	result:	FLTARR of 4 x m of coverted POS vectors.  If pos[3,i] was not out of bounds, the input POS is output without
		any manipulation

PROCEDURE:
	First off, I'm pissed that I didn't realized I'd need this function until now.  Although the POS vector still uniquely
	determines the hyperbola, the plasma view can vary from being l > 0 to l < 0 depending on the points used.  
	Although an extra bit (or encoded on R_TANG since it's always > 0) to tell the direciton in l towards the plasma could solve the
	problem it wouldn't work with existing codes (GENPOS_VOL_COEFS).  Instead, a POS vector can be found that is along the 
	same hyperbola but has l > 0 describing the path through plasma.  To do this, a boundary in R and Z is needed that will
	outside the plasma.  The inverted pos vector will have an (R1,Z1) on this boundary, the same R_TANG and a new PSI that
	is inbounds.  The LINE_PATH_PLOTS of a set of POS vectors where some have been inverted will look awkward but their utility

MODIFICATION HISTORY
	Written by:	ML Reinke: 8-28-06

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_LHAT">
<H2>GENPOS_LHAT</H2></A>
<A HREF="#GENPOS_INVERT_POS">[Previous Routine]</A>
<A HREF="#GENPOS_LINE_BR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_LHAT

PURPOSE:
	This function computes the unit vector components for a single line of sight at
	certain points on a GENPOS_GRID.

CALLING SEQUENCE:
	result=GENPOS_LHAT(pos,gridpts)

INPUTS:
	pos		FLTARR [Ro,Zo,Rt,psi] pos vector paramterizing line of sight
	gridpts		STRUC of plasma grid.  Use output of GENPOS_GRID or GRID_VES with /center

OPTIONAL INPUTS:
	good:		INTARR of the points (R,Z) = (gridpts.pnts[0,good], gridpts.pnts[1,good]) that you
			want the calculation done fore.  DEFAULT is all of gridpts but this shouldn't be
			used.  Typically good=where(gpv[i,*] GT 0) should input.  See procedure for why.

KEYWORD PARAMETERS:
	debug:		/debug will stop the code before the output is returned
	rev:		/rev assumes that the POS vector has been reversed (due to position problems) and *= lz and lphi and lr by -1.0
	diff:		/diff calculates lr from sqrt(1.0-lz^2-lphi^2).  Good for poloidal arrays

OUTPUTS:
	result:		STRUC of unit vectors in cylindrical coordinates (R,phi,Z)
			*.lr	unit vector in the radial (major radius) direction ***see restrictions***
			*.lphi 	unit vector in the polar angle (toroidal) direction
			*.lz	unit vector in the vertical (vertical) direction

RESTRICTIONS:
	The values of result.lr will be valid when pos[3] is well away from 0.  At psi=0 the unit vector is degenerate since
	on the way in it points inward and on the way out it points outward.  For gridded plasmas there will be a range above and below
	psi=0 where the view will enter and exit along the same horizontal slice of pixels.

	****NOTE 8/08/07: LHAT VALUES CAN NOW BE CALCULTED USING GENPOS_VOL_COEFS****

PROCEDURE:
	This function isn't complete but it's getting the job done right now.  If you take the total of the unit vector it will
	be slightly greater or less than one due to approximations.  This error should decrease as smaller voxel sizes are used.  


MODIFICATION HISTORY:
	Written by: 	ML Reinke - 6/04/07
	8-08-07:	ML Reinke - fixed a bug that was calculating lr with the wrong sign.
	2-12-08:	ML Reinke - further patched this crumbling shitty function (rev and diff)
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_LINE_BR">
<H2>GENPOS_LINE_BR</H2></A>
<A HREF="#GENPOS_LHAT">[Previous Routine]</A>
<A HREF="#GENPOS_PLANAR2GPV">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_LINE_BR

PURPOSE:
	This function calculates the line-integrated brightness for an emissivity profile and given set of POS vectors.  This
	duplicates, in part the LINE_BR functionality.

CALLING SEQUENCE:
	result=GENPOS_LINE_BR(pos,emiss,r,t,shot,tau)

INPUTS:
	pos	FLTARR	[4,nch] of the POS vectors
	emiss	FLTARR	[nr,nt] of the emissivity [X/m^3]
	r	FLTARR	[nr] of the radial scale vector [m]
	t	FLTARR	[nt] of the time scale [sec]
	shot	LONG	shot number
	tau	FLTARR	[ntau] of the time points at which to calculate the brightness [sec]

OPTIONAL INPUTS:
	emerr	FLTARR	[nr,nt] of the uncertainty in emissivity [X/m^3]
	n_s	INT	number of points to discretize along line of sight DEFAULT=75
	rmap	FLTARR	of the mapping data to reinsert for different emissivities
	efit	STRUC	of EFIT data to resinsert for different emissivities
	
KEYWORD PARAMETERS:
	rho	/rho assums that the r input is actually r/a
	verb	/verb displays (a lot) of status messages
	debug	/debug stops the code at various points for inspection
	
OUTPUTS:
	result	FLTARR	[nch,nt] of the line-integrated brightness [X/m^2]
	
OPTIONAL OUTPUTS:
	brerr	FLTARR	[nch,nt] of the uncertainty in result [X/m^2]
	efit	STRUC	of EFIT data to be used as optional input
	rmap	FLTARR	of mapping data to be used as optional input

MODIFICATION HISTORY:
	Written by:	M.L. Reinke - 4/18/12 (adapted from LINE_BR)

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_PLANAR2GPV">
<H2>GENPOS_PLANAR2GPV</H2></A>
<A HREF="#GENPOS_LINE_BR">[Previous Routine]</A>
<A HREF="#GENPOS_PLANAR2POS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_PLANAR2GPV

PURPOSE:
	This function takes in a planar INFO structure and a grid and uses GENPOS_VOL_COEFS to determine
	the volume weights on a poloidal grid.
	
CALLING SEQUENCE:
	result=GENPOS_PLANAR2GPV(info,ves_grid)

INPUTS:
	info:		STRUC of detector information (see GENPOS_PLANAR_INFO)
	ves_grid:	STRUC of pixel grid boundaries (see GENPOS_GRID) that will be passed to GENPOS_VOL_COEFS
				which means /center should NOT be used.

OPTIONAL INPUTS:
	n_ap:		INT/INTARR of aperture griding.  If n_ap is INT then there will be n_ap x n_ap grid (square spacing)
				If n_ap is INTARR [nx,ny], then there will be n_ap[0]*n_ap[1] grids.  DEFAULT = 3
	n_det:		INT/INTARR of detector griding (same as n_ap) DEFAULT = 3
	path:		STR of path where the output will be saved DEFAULT = '/home/username/genie/data/gpv/gpv.dat'
	lpath:		STR of the path where the lhat optional output, if selected, will be stored.  
				DEFAULT = '/home/username/genie/data/lhat/lhat.dat'
	detector:	INT of detector out of the array to for which GENPOS_VOL_COEFS will be run.  This is primarily for debugging purposes.
	lhat:		Set lhat to a non-zero named variable and it will be filled with the optional output lhat structure	

KEYWORD PARAMETERS:
	raw:		/raw returns the non-summed output of GENPOS_VOL_COEFS (see optional outputs below)
	gpv_debug:	/gpv_debug sends a /debug to GENPOS_VOL_COEFS
	gpv_plots:	/gpv_plots sends a /plots to GENPOS_VOL_COEFS
	gpv_contour:	/gpv_contour sends a /contour to GENPOS_VOL_COEFS
	gpv_ps:		/gpv_ps sends a /ps to GENPOS_VOL_COEFS
	quiet:		/quiet doesn't display status information about current channel being processed
	debug:		/debug stops before the RETURN statement

OUTPUTS:
	result:		FLTARR of m x n volumes [m^3] where m is the number of detectors described in the info file and n is the
				number of grid points (ves_grid.n[0]*ves_grid.n[1]).

OPTIONAL OUTPUTS:
	ves_cent:	STRUC the ves_cent structure calculated using GENPOS_GRID2CENT that is stored with the GPV and LHAT data.
	lhat:		STRUC of the average unit vectors in (r,phi,z) (w/o /raw invoked)
			*.lr	STRUC sub structure for the radial unit vector data
				*.in	FLTARR [n, m] of the average radial unit vector going in
				*.dvin	FLTARR [n, m] of the volume weightings going in
				*.out	FLTARR [n, m] of the average radial unit vector coming out
				*.dvout	FLTARR [n, m] of the volume weightings coming out
			*.lphi	FLTARR [n, m] of the average toroidal unit vector
			*.lz	FLTARR [n, m] of the average vertical unit vector

	===================================================R A W================================================================

	If a /raw is used then the output array will be STRUC that holds the unsummed GPV data.  If the array was stored as a 
	3D data set the size would be unreasonable, even for a modest number of channels.  Honestly, I crashed IDL cause I ran out
	of memory. Yeah what's up now punk!

	result: 	STRUC containing gpv for each UPOS for each detector only for non-zero elements
			*.d0	gpv and spatial information for detector 0
				*.tmp	LONARR 	[#non_zero] of array elements
				*.gpv	FLTARR 	[#non_zero,l] of gpv values [1/m^3]
			*.d1	gpv and spatial information for detector 0
			  .			 .
			  .			
			*.dn	gpv and spatial information for detector n	

	The *.dx.tmp array correspond to array locations (R,Z)=(ves_cent.pnts[0,tmp] and ves_cent.pnts[1,tmp]) while
	the *.dx.gpv array are the volume coefficients at those points.  Similarly, the lhat structure will be stored in a condensed
	form when /raw is invoked.

	lhat: 		STRUC containing lhat structures for each UPOS for each detector only for non-zero elements
			*.d0	lhat and spatial information for detector 0	
				*.tmp	LONARR 	[#non_zero] of array elements
				*.lhat	STRUC	of lhat data
					*.lr	STRUC of unit vectors in the radial (major radius) direction (in and out)
						*.in	FLTARR [#non_zero] of the average radial unit vector going in
						*.dvin	FLTARR [#non_zero] of the volume weightings going in
						*.out	FLTARR [#non_zero] of the average radial unit vector coming out
						*.dvout	FLTARR [#non_zero] of the volume weightings coming out
					*.lphi 	FLTARR [#non_zero] average unit vector in the polar angle (toroidal) direction
					*.lz	FLTARR [#non_zero] average unit vector in the vertical (vertical) direction
       ========================================================================================================================

RESTRICTIONS:
	This codes uses GENPOS_GRID to generate the detector and aperture grids, GENPOS_UPOS to process grids and
	then GENPOS_VOL_COEFS to find the volume coefficents.  Not all optional inputs are carried through to
	GENPOS_VOL_COEFS.

MODIFICATION HISTORY:
	Written by:	ML Reinke 7-27-06
	8-12-06:	ML Reinke - added the RAW output option
	8-31-06:	ML Reinke - added the detector optional input
	8-08-07:	ML Reinke - added the ability to get lhat as an optional output and select a
                                   save path for lhat data.
	8-08-07:	ML Reinke - now calcualted ves_cent using GENPOS_GRID2CENT and saves with gpv and lhat	
	8-08-07:	ML Reinke - overhauld how /raw data is stored to save space, now only non_zero values are stored
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_PLANAR2POS">
<H2>GENPOS_PLANAR2POS</H2></A>
<A HREF="#GENPOS_PLANAR2GPV">[Previous Routine]</A>
<A HREF="#GENPOS_PLANAR2UPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_PLANAR2POS
	
PURPOSE:
	This function takes a planar information structure and returns the corresponding POS vectors.

CALLING SEQUENCE:
	result=GENPOS_PLANAR2POS(info)

INPUTS:
	info:		STRUC of detector information (see GENPOS_PLANAR_INFO)
	t:		FLT of the aperture thickness [meters]

KEYWORD PARAMETERS:
	debug:		/debug stops before the RETURN statement

OUTPUTS:
	result:		FLTARR 4 x m where m is the number of detector positions in info.det.xi and info.det.zeta

OPTIONAL OUTPUTS:
	etendue:	FLTARR of length m of the etendue for each detector
	umod:		FLTARR of length m of the etendue mod for each detector due to finite thickness (u=etendue*umod)

RESTRICTIONS:
	This function calls GENPOS to generate the POS vectors as well as calculate the etendues.

MODIFICATION HISTORY:
	Written by:	ML Reinke 7-27-06
	11-2-07:	ML Reinke - added the t optional input and umod optional output to compute
                                   finite aperture thickness etendues

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_PLANAR2UPOS">
<H2>GENPOS_PLANAR2UPOS</H2></A>
<A HREF="#GENPOS_PLANAR2POS">[Previous Routine]</A>
<A HREF="#GENPOS_PLANAR_INFO">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_PLANAR2UPOS

PURPOSE:
	This function takes in a planar INFO structure and a grid and uses GENPOS_VOL_COEFS to determine
	the volume weights on a poloidal grid.
	
CALLING SEQUENCE:
	result=GENPOS_PLANAR2UPOS(info)

INPUTS:
	info:		STRUC of detector information (see GENPOS_PLANAR_INFO)

OPTIONAL INPUTS:
	n_ap:		INT/INTARR of aperture griding.  If n_ap is INT then there will be n_ap x n_ap grid (even spacing)
				If n_ap is INTARR [nx,ny], then there will be n_ap[0]*n_ap[1] grids.  DEFAULT = 3
	n_det:		INT/INTARR of detector griding (same as n_ap) DEFAULT = 3
	path:		STR of path where the output will be saved DEFAULT = '/home/username/genie/data/gpv/upos.dat'

KEYWORD PARAMETERS:
	quiet:		/quiet doesn't display status information about current channel being processed
	debug:		/debug stops before the RETURN statement

OUTPUTS:
	result:		FLTARR of 4 x n x m position vectors [m^3] where m is the number of detectors described in the info file and n is the
				number of connecting points (n_ap[0]*n_ap[1]*n_det[0]*n_det[1])

RESTRICTIONS:
	This codes uses GENPOS_GRID to generate the detector and aperture grids, GENPOS_UPOS to process grids.

MODIFICATION HISTORY:
	Written by:	ML Reinke 8-18-06 (adapted from GENPOS_PLANAR2GPV)
	
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_PLANAR_INFO">
<H2>GENPOS_PLANAR_INFO</H2></A>
<A HREF="#GENPOS_PLANAR2UPOS">[Previous Routine]</A>
<A HREF="#GENPOS_POLOIDALPOS2RT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_PLANAR_INFO

PURPOSE:
	This function creates an detector information structure that can be used with other
	functions in GENIE to create POS vectors and GPV data.  This function can only handle
	a planar type of information file.  Data is entered in an ASCII format
	
CALLING SEQUENCE:
	result=GENPOS_PLANAR_INFO(path)
	
INPUTS:
	path	STR path to info file

KEYWORD_PARAMETERS:
	debug:	/debug stops the code before returning

OUTPUTS:
	resut:	STRUC of information describing the detector view.
		*.name		STR name of the view
		*.ap		STRUC aperture substructure
		*.*.vec		FLTARR [ro,0.0,zo] of aperture [meters]
		*.*.rot		FLTARR [alpha,beta,gamma] of aperture normal [radians]
		*.*.size	FLTARR [y,z] of aperture dimensions [meters]
		*.det		STRUC detector substructure
		*.*.x0
		*.*.x1		x3 FLTARR that locate the detector plane in aperture coordinates [meters]
		*.*.x2
		*.*.xi		FLTARR of xi locations of pixels on the detector [meters]
		*.*.zeta	FLTARR of zeta locations of pixels on the detector [meters]
		*.*.size	FLTARR [xi,zeta] of detector dimensions [meters]
		*.type		STR of type (must be planar)
		*.author	STR name of the author of the info file

	If path points to an info file that doesn't have (on the second line) 'type = planar' then the
	function will RETURN, -1


RESTRICTIONS:
	There are formatting issues with the INFO file.  See /home/mlreinke/idl/genie/data/info/planar_template.info 
	to get a template to enter the data.  Contact the author with questions.

MODIFICATION HISTORY:
	Written by:	ML Reinke: 7-28-06
	8-9-06:		ML Reinke - adjusted the reading of lengths from millimeters to centimeters

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_POLOIDALPOS2RT">
<H2>GENPOS_POLOIDALPOS2RT</H2></A>
<A HREF="#GENPOS_PLANAR_INFO">[Previous Routine]</A>
<A HREF="#GENPOS_POS2RMIDTANG">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_POLOIDALPOS2RT

PURPOSE:
	This procedure caclulates tangency radii for poloial views, assuming that the flux surfaces
	are circles with ROUT, the center of the LCFS as the center.

CALLING SEQUENCE:
	GENPOS_POLOIDALPOS2RT,shot,pos,rt,time

INPUTS:
	shot:		LONG 	shot number
	pos:		FLTARR	[4,n_ch] of the view information
	
OUTPUTS:
	rt:		FLTARR	[n_ch,n_time] of the tangency radii [m]
	time:		FLTARR	[n_time] of the time points (EFIT TIME GRID) [s]	

OPTIONAL OUTPUTS:
	rout:		FLTARR	[n_time] of the center of the LCFS, assumed to be radial center of circular flux surfaces [m]
	zmag:		FLTARR	[n_time] height of the magnetic axis, assumed to be vertical center of circular flux surfaces [m]

MODIFICATION HISTORY:
	Written by:	ML Reinke - 2/20/08

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_utility.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_POS2RMIDTANG">
<H2>GENPOS_POS2RMIDTANG</H2></A>
<A HREF="#GENPOS_POLOIDALPOS2RT">[Previous Routine]</A>
<A HREF="#GENPOS_POS2VOXEL_MATRIX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_POS2RMIDTANG

PURPOSE:
	This function turns an array of pos vectors into an array of RMID values that correspond to the
	flux surfaces of closest approach.

CALLING SEQUENCE:
	result=GENPOS_POS2RMIDTANG(pos,shot,time)

INPUTS:
	pos:	FLTARR 	[4,n_pos] of [Ro,Zo,Rt,PSI] x m position vectors
	shot:	LONG	shot number for EFIT reference
	time	FLTARR 	[n_time] of arbitrary length of the time points on which to perform operation
	
OPTIONAL INPUTS:
	n_s:	INT	number of points to subdivide line before call to EFIT_RZ2RMID, DEFAULT: 40
	rzbnd		FLTARR 	[r_min,r_max,|z|] of the rectangular bounding box for the lines DEFAULT: [0.44,1.0,0.45]
	tree:		STRING	of the EFIT tree to use for calculating weighting matrix [DEFAULT: 'analysis']\

KEYWORD PARAMETERS:
	rho:	/rho is carred through to EFIT_RZ2RMID to output rho values instead of rmid
	psin:	/psin runs EFIT_RZ2RHO instead of EFIT_RZ2RMID
	efit:	/efit runs RZ2RMID on the EFIT time base instead of the time input.  The output data interpolates this result onto
			the time base.  This is useful for diode data that has better time resolution than EFIT

OUTPUTS:
	result:	FLTARR 	[n_pos, n_time] of outboard major radii [m] of the flux surface of closest approach
			for each POS vector (or r/a if /rho used or normalized poloidal flux if psinorm is used

PROCEDURE:
	The line of sight is subdivided into n_s parts and LINE_R and LINE_Z are used to find (R,Z) points
	in the chamber.  One call, for all channels at all times, is sent to EFIT_RZ2RMID to save on computation.


MODIFICATION HISTORY:
	Written by:	ML Reinke - 7/22/07
	1-17-08:	ML Reinke - added the keyword parameter EFIT which runs EFIT_RZ2RMID on the
                                   EFIT time base and then interpolates results to the input time base
	1-17-08:	ML Reinke - updated the s_min,s_max finder to include vertical bounderies and
                                   added rzbnd optional input
	1-30-09:	ML Reinke - fixed a bug by limiting the minimum RMID to those |z_pos| < rzbnd[2]
	9-23-10:	ML Reinke - added the psinorm keyword 
	1-05-11:	ML Reinke - if user doesn't confirm that time is inside valid EFITs, then RZ2XXX
                                   will return NANs and crash.  Fixed it so rhotang = 0 will be returned
                                   instead in these cases
	6-13-11:	ML Reinke - added the tree optional input for use with EFIT_RZ2XXX codes.

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_utility.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_POS2VOXEL_MATRIX">
<H2>GENPOS_POS2VOXEL_MATRIX</H2></A>
<A HREF="#GENPOS_POS2RMIDTANG">[Previous Routine]</A>
<A HREF="#GENPOS_POS_REFORM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_POS2VOXEL_MATRIX

PURPOSE:
	This function creates a voxel matrix using a pos vector and an etendue vector using an EFIT reconstruction

CALLING SEQUENCE:
	result=genpos_pos2voxel_matrix(pos,u,shot)

INPUTS:
	pos:		FLTARR	[4,n_ch] of the [Ro,Zo,Rt,Psi] for each channel 
	u		FLTARR	[n_ch] of the etendue for each channel [m^2-str]
	shot:		LONG	of the shot number for EFIT reference

OPTIONAL INPUTS:
	tpts:		FLTARR	of the time points to calculate the voxel matrix DEFAULT = all EFIT times
	n_s:		INT	number of points along line of sight to divide view into DEFAULT: 300
	rzbnd		FLTARR 	[r_min,r_max,|z|] of the rectangular bounding box for the lines DEFAULT: [0.44,1.0,0.45]
	rho_min		FLT	minimum value of rho to be used DEFAULT: 0.0
	n_rho		INT	number of rho points to use DEFAULT: 20
	rho_vec		FLTARR	of the rho points for which the voxel matrix is created: DEFAULT: make(rho_min,1.0,n_rho)
	rz_ap		FLTARR  [R_ap, Z_ap] of the aperature to start the line of sight at instead of detector [Ro,Zo]
	r_ap		FLT	of the R value to translate the pos vector to to start the tracing.
	exp_rho:	FLT	of the scaling past the last rho point to include in the last bin DEFAULT: 1.85*n_rho
	kdebug:		INT	channel number to stop the voxel filling code at for debugging DEFAULT: OFF
	ro:		FLT	value of the major radius of the magnetic axis [m] DEFAULT: 0.68
	a_rho:		FLTARR	[n_rho] of the exponential asymmetry term.  Used in iteration 1 and beyond (see PROCEDURE)
	m:		INT	of the poloidal m number of the sine/cosine weighting matrix (if selected) DEFAULT: 1
	tree:		STRING	of the EFIT tree to use for calculating weighting matrix [DEFAULT: 'analysis']

KEYWORD PARAMETERS:
	debug:		/debug stops the function before the RETURN statement
	inout:		/inout multiplies each voxel weighting by an asymmetry term (see PROCEDURE)
	sine:		/sine multiples each voxel weighting by sine (using (R,Z) pt and magnetic axis at time point)
	cosine:		/cosine multiples each voxel weighting by cosine (using (R,Z) pt and magnetic axis at time point)

OUTPUTS
	result:		FLTARR [n_ch, n_rho, n_time] of the voxel weightings for each channel at each rho to be used in profile inversion
				at each time point.

OPTIONAL OUTPUTS:
	rho_vec:	FLTARR if set to an unnamed variable it will be filled with the rho vector used if it is not input through rho_vec.
	rhopts:		FLTARR [n_ch*n_s,n_time] of the rho values for all the channels along the lines of sight for each time
				slice.  This output is tied to a specific pos,tpts and n_sinput and is useful for iterating on rho_vec.

PROCEDURE:
	When /inout is invoked without a_rho, the asymmetry term R^2/Ro^2-1.0) is multiplied into the volume term, which is
	used to derive a_rho.  If a_rho is given and /inout set, then the asymmetry term exp(a_interp*(r_ch[j]^2/ro^2-1.0)) 
	is used which will allow a better first order emissivity profile to be calculated.

MODFICATION HISTORY:
	Written by:	ML Reinke 12/21/07
	1-03-08:	ML Reinke - updated the voxel filling to interpolate the volume element to the two nearest bins.
					added the exp_rho optional input to handle the edge bin
	1-04-08:	ML Reinke - fixed a bug in the previous mod that would cause a bin to goto NAN if mapped rho value EQ a bin rho
	1-09-08:	ML Reinke - added the rhopts optional output so iterations can be done on rho_vec and save time
	1-31-08:	ML Reinke - added the ability to fit a rotation induced in/out asymmetry (see inout, ro, a_rho)
	7-15-08:	ML Reinke - added the ability to generate sine or cosine asymmetry weighted voxel matrices
	8-12-10:	ML Reinke - added the r_ap optional input which allows the n_s to start from a defined major radius rather than the aperature.
   	4-21-11:	ML Reinke - updated the verb output to specify the type of matrix
	6-13-11:	ML Reinke - added the tree optional input for use with EFIT_RZ2XXX codes.	

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_POS_REFORM">
<H2>GENPOS_POS_REFORM</H2></A>
<A HREF="#GENPOS_POS2VOXEL_MATRIX">[Previous Routine]</A>
<A HREF="#GENPOS_PROFILE_INVERT:">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_POS_REFORM
	
PURPOSE:
	This function reformulates POS vectors so that their (R,Z) starting points are on a perscribed boundary
	
CALLING SEQUENCE:
	GENPOS_POS_REFORM,pos,rzbnd

INPUTS:
	pos		FLTARR	[4,n_pos] of the input POS vector
	rzbnd:		FLTARR	[4] [R_in,R_out,Z_top,Z_bot] in [m] of the rectangular boundary

OUTPUTS:
	pos:		FLTARR	[4,n_pos] of the reformulated POS vector (copies over input)
	
OPTIONAL OUTPUTS:
	old_pos:	FLTARR	[4,n_pos] a copy of the input POS vectors

MODIFICATION HISTORY:
	Written by:	ML Reinke - 1/30/08

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_utility.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_PROFILE_INVERT:">
<H2>GENPOS_PROFILE_INVERT:</H2></A>
<A HREF="#GENPOS_POS_REFORM">[Previous Routine]</A>
<A HREF="#GENPOS_ROT_MATRIX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_PROFILE_INVERT:
	
PURPOSE:
	This function inverts a 1D moment profile given the moment, the voxel weighting matrix and
	a smoothing parameter to get the local moment/volume.  Basically the ill-conditioned b = V*a is inverted
	to calculate a given measurements of b using linear-regularization.

CALLING SEQUENCE:
	result=GENPOS_PROFILE_INVERT(mom,voxel,eps)

INPUTS:
	mom:		FLTARR of length m of "brightnesses" to be inverted
	voxel:		FLTARR of size m x n of the spatial weighting coefficients [inside-->outside]
	eps:		FLT weighting of the regularization matrix

OPTIONAL INPUTS:
	eta:		FLT weighting coefficient for the edge zero DEFAULT: 0.0 
	err:		FLTARR of length m of the statistical error in the input mom
	n_err_inv:	INT number of inversions to complete when caclulation error propigation DEFAULT: 1000 [NO LONGER DOES ANYTHING 2-16-09]
	nprof:		INT the number of spatial profiles that voxel is describing (radial+sine+cosine for example).  
				This will adjust regularization matrices accordingly.
	inv_matrix:	DBLARR of the inverted least squares/smoothing matrix

KEYWORD PARAMETERS:
	svdc:		/svdc inverts using singular value decomposition (SSVDC) where the default is LA_INVERT
	nofirst:	/nofirst removes the weighting of the weighting of the first derivative to be used when profile does not goto rho=0.

OUTPUTS:
	result:		FLTARR of length n of the "emissivity" from the inversion

OPTIONAL OUTPUTS:
	svdout:		STRUC if /svdc is called then this struc is filled with the outputs of SSVDC
	brchk:		STRUC of the brightness check
				*.mom FLTARR of length m of voxel#result which is a check on the quality of the inversion
				*.inverr FLTARR [n] of the emissivity error using propigation of error on the matrix equation.
				  DEFAULT will be zeros if optional input err is not set
	inv_matrix:	DBLARR of the inverted least squares/smoothing matrix

PROCEDURER:
	This is routine method for inverting noisy profile that have suffcient spatial sampling of a profile.  It is assumed
	that the output emissivity profile will be in rho or psi so that the derivative on axis should be zero.  Use
	GENPOS_POS2VOXEL_MATRIX, GENPOS_GPV2VOXEL_MATRIX or GENPOS_GPV2VOXEL_VEL_MATRIX to general voxel.  The correct ordering is for the
	lower values of mom to be from the innermost choords.

	Inversion errors can be calculated if the error of the mom "brightness" profile is included.  Many (n_err_inv) inversions
	are done with the same length/weighting matrix varying the mom profile by random noise who magnitude is perscribed by the err optional input.

MODIFICATION HISTORY:
	Written by: 	ML Reinke - June 2007
	7-17-07:	ML Reinke - added the inv_matrix optional output for use in GENSPEC if EPS_EM and EPS_TI are the same.
	8-15-07:	ML Reinke - added the edge zero controlled by weighting factor eta
	10-30-08:	ML Reinke - added the err and n_err_inv optional inputs and the inverr
                                   output in the brchk structure. These allow statistical error to be calculated.
	11-04-08:	ML Reinke - added the nprof optional input which adjust the regularization
                                   matrix to reflect multiple spatial profiles are being fit at the same time.                                  
	2-16-08:	ML Reinke - switched the inversion error calculation over to propigation error from doing multiple inversions
	4-21-11:	ML Reinke - added the ability to use the inv_matrix as an optional input so user can speed up inversions

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_ROT_MATRIX">
<H2>GENPOS_ROT_MATRIX</H2></A>
<A HREF="#GENPOS_PROFILE_INVERT:">[Previous Routine]</A>
<A HREF="#GENPOS_RZ2PSITH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_ROT_MATRIX

PURPOSE:
	This function generates the 3 x 3 rotation matrix used to
	transform coordinates from the (xyz) aperature coordinate system to
	the (x''' y''' z''') coordinate system whos axes are parallel
	to the XYZ coordinates in which the tokamak center is located.

CALLING SEQUENCE
	result=GENPOS_ROT_MATRIX(a,b,g)

INPUTS:
	a:	FLT angle alpha (in radians) in FIGURE 7
	b:	FLT angle beta (in radians) in FIGURE 7
	c:	FLT angle gamma (in radians) in FIGURE 7

OUTPUTS:
	result:	FLTARR 3 x 3 matrix for which (xyz)''' can be determined
		using result##[x,y,z].

PROCEDURE:
	The rotation angles alpha, beta and gamma locate the view of
	the aperature normal w/r/t the tokamak center.  More
	description is given FIGURE 7 of the General Equations paper.

MODIFICATION HISTORY:
	Written by:  	ML Reinke  - June 2006
	ML Reinke	6-09-06 fixed an embarasses matrix multiplication error
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_RZ2PSITH">
<H2>GENPOS_RZ2PSITH</H2></A>
<A HREF="#GENPOS_ROT_MATRIX">[Previous Routine]</A>
<A HREF="#GENPOS_SPHERE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_RZ2PSITH

PURPOSE:
	This procedure uses EFIT data to covert a series of (r,z) points to (psi,th) points
	where psi is normalized

CALLING SEQUENCE:
	GENPOS_RZ2PSITH,r,z,shot,time,psi,th

INPUTS:
	r:	FLTARR	of major radius points [meters] of length n_r
	z:	FLTARR	of height points [meters] (must be same length as r)
	shot:	LONG	shot number
	time:	FLTARR	of time points at which to do computation [sec] of length n_t

OUTPUTS
	psi:	FLTARR [n_r,n_t] of normalized psi values
	th:	FLTARR [n_r,n_z] of theta values

PROCEDURE:
	Normalized psi values are computed using EFIT_RZ2RHO with /psinorm optional input
	Theta values are computed by taking a tangent of (z-zo)/(r-ro) which is not a strict
	defination of theta, but it's what I'm working with for now.

MODIFICATION HISTORY:
	Written by:	ML Reinke 12/13/07

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_utility.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_SPHERE">
<H2>GENPOS_SPHERE</H2></A>
<A HREF="#GENPOS_RZ2PSITH">[Previous Routine]</A>
<A HREF="#GENPOS_SPHERE_UPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_SPHERE

PURPOSE:
	This function calculates the POS vector and etendue for a set of detector points
	given detector position and mirror position information usually specified by an INFO file.
	This traces rays from the detector through the center of the mirror.

CALLING SEQUENCE:
	result=GENPOS_SPHERE(m_vec,m_rot,m_rad,x0,x1,x2,det_pos)

INPUTS:
	m_vec: 		FLTARR 	[ro, 0.0, zo] where ro and zo is the mirror position [meter]
	m_rot:		FLTARR 	[alpha,beta,gamma] set of orientation angles of the mirror [in radians]
	m_rad:		FLOAT 	of the mirror radius of curvature [meter]
	x0:
	x1:		x3 FLTARR locations of the detector's fiducial points in the mirror coordinate system
	x2:
	det_pos:	FLTARR 	[2 x m] where m is the number of points in the deteector plane
				for which GENPOS_SPHERE will cacluate POS vectors

OPTIONAL INPUTS:
	a_det:		FLOAT area of detector DEFAULT = 1.0
	a_m:		FLOAT area of mirror DEFAULT = 1.0
	
KEYWORD PARAMETERS:
	debug:		/debug stops before the RETURN statements

OUTPUTS:
	result:		FLTARR [ro,zo,rt,psi] x m position vectors

OPTIONAL OUTPUTS:
	etendue:	FLTARR [m] of etendue values

MODIFICATION HISTORY:
	Written by:	M.L. Reinke 1/10
	8/5/10:		M.L. Reinke - Changed variable labeling that was screwing up the etendue calculation
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_SPHERE_UPOS">
<H2>GENPOS_SPHERE_UPOS</H2></A>
<A HREF="#GENPOS_SPHERE">[Previous Routine]</A>
<A HREF="#GENPOS_SPHERICAL2POS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_SPHERE_UPOS

PURPOSE:
	This function calculates POS vectors for a finite sized mirror.

CALLING SEQUENCE:
	result=GENPOS_SPHERE_UPOS(m_vec,m_rot,m_rad,x0,x1,x2,m_grid,det_grid)

INPUTS
	m_vec: 		FLTARR 	[ro, 0.0, zo] where ro and zo is the mirror position [meters]
	m_rot:		FLTARR 	[alpha,beta,gamma] set of orientation angles of the mirror [in radians]
	m_rad:		FLOAT 	of the mirror radius of curvature [meter]
	x0:
	x1:		x3 FLTARR locations of the detector's fiducial points in the mirror coordinate system
	x2:
	m_grid:		FLTARR 	[3,num_m] of the <x,y,z> points on the mirror
	det_grid:	FLTARR 	[2,num_det] of the <xi,zeta> points on the detector plane

KEYWORD PARAMETERS:
	debug		/debug will stop the code before the RETURN 
	
OUTPUTS:
	result:		FLTARR	[4,num_m,num_det] of the POS vector for each det/mirror grid point

OPTIONAL OUTPUTS:
	du:		FLTARR	[num_m,num_det]	of the etendue for each det/mirror grid point
	thb:		FLTARR	[num_m,num_det] of the bragg angle for each det/mirror grid point [radians]
	bigXYZ:		FLTARR	[3,num_m,num_det,3] of the XYZ (tokamak) coordiates of:
				[*,*,*,0] - the detector point
				[*,*,*,1] - the mirror point
				[*,*,*,2] - the reflected point
	
MODIFICATION HISTORY:
	Written by:	ML Reinke 1/10
	2/27/10		ML Reinke - changed the output array formatting to seperate out each mirror/det combination
	8/20/10		ML Reinke - updated so that the du and thb optional outputs are calculated

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_SPHERICAL2POS">
<H2>GENPOS_SPHERICAL2POS</H2></A>
<A HREF="#GENPOS_SPHERE_UPOS">[Previous Routine]</A>
<A HREF="#GENPOS_SPHERICAL2QUADCURVE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_SPHERICAL2POS
	
PURPOSE:
	This function takes a spherical information structure and returns the corresponding POS vectors.

CALLING SEQUENCE:
	result=GENPOS_SPERICAL2POS(info)

INPUTS:
	info:		STRUC of detector information (see GENPOS_SPHERICAL_INFO)

KEYWORD PARAMETERS:
	debug:		/debug stops before the RETURN statement

OUTPUTS:
	result:		FLTARR 4 x m where m is the number of detector positions in info.det.xi and info.det.zeta

OPTIONAL OUTPUTS:
	etendue:	FLTARR of length m of the etendue for each detector

RESTRICTIONS:
	This function calls GENPOS to generate the POS vectors as well as calculate the etendues.

MODIFICATION HISTORY:
	Written by:	ML Reinke 1/10

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_SPHERICAL2QUADCURVE">
<H2>GENPOS_SPHERICAL2QUADCURVE</H2></A>
<A HREF="#GENPOS_SPHERICAL2POS">[Previous Routine]</A>
<A HREF="#GENPOS_SPHERICAL2UPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_SPHERICAL2QUADCURVE

PURPOSE:
	This function generate the coefficients for the quadradic curve on the detector plane
	in pixel space (xi,zeta) given an info file and a wavelength.

CALLING SEQUENCE:
	result=GENPOS_SPHERICAL2QUADCURVE(info,lam_o)

INPUTS:
	info	STRUC	output of GENPOS_SPHERICAL_INFO
	lam_o	FLOAT	wavelength [Ang]

OUTPUTS:
	result:	FLTARR [6] of the quaddradic curve coefficients [a,b,c,d,f,g]
		such that xi and zeta to be specified in pixel #'s not physical length

PROCEDURE:
	The coffiencts specify the curve in the equation:
		a*xi^2+2*b*xi*zeta+c*zeta^2+2*d*xi+2*f*zeta+g=0
	and the derivation of the dependance of the coefficients on the INFO file parameters can
	be found in "General Equations for X-Ray Crystal Imaging Spectroscopy in Tokamaks" Section 3.

	The outputs can be used in functions like ELLIPSE_XPT which given zeta's calculate xi's of the
	(usually) ellipse defined by the detector/mirror alignment in the INFO file.

MODFICATION HISTORY:
	Written by: 	M.L. Reinke 1/10
	8/11		M.L. Reinke - added the phi input to move the origin in x-y plane
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_SPHERICAL2UPOS">
<H2>GENPOS_SPHERICAL2UPOS</H2></A>
<A HREF="#GENPOS_SPHERICAL2QUADCURVE">[Previous Routine]</A>
<A HREF="#GENPOS_SPHERICAL_INFO">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_SPHERICAL2UPOS

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_SPHERICAL_INFO">
<H2>GENPOS_SPHERICAL_INFO</H2></A>
<A HREF="#GENPOS_SPHERICAL2UPOS">[Previous Routine]</A>
<A HREF="#GENPOS_SPHERICAL_REFL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_SPHERICAL_INFO

PURPOSE:
	This function creates an detector information structure that can be used with other
	functions in GENIE to create POS vectors and GPV data.  This function can only handle
	a spherical bragg reflector type of information file.  Data is entered in an ASCII format
	
CALLING SEQUENCE:
	result=GENPOS_SPERICAL_INFO(path)
	
INPUTS:
	path	STR path to info file

KEYWORD_PARAMETERS:
	debug:	/debug stops the code before returning

OUTPUTS:
	resut:	STRUC of information describing the detector view.
		*.name		STR name of the view
		*.m		STRUC mirror substructure
		*.*.vec		FLTARR [ro,0.0,zo] of aperture [meters]
		*.*.rot		FLTARR [alpha,beta,gamma] of aperture normal [radians]
		*.*.size	FLTARR [y,z] of aperture dimensions [meters]
		*.*.bragg	STRUC of the bragg information
		*.*.*.twod	FLOAT of the 2d spacing [Ang]
		*.*.*.iref	FLOAT of the integrated reflectivity
		*.*.*.rwid	FLOAT of the rocking curve width [mRad]
		*.*.rad		FLOAT of the mirror radius [m]
		*.det		STRUC detector substructure
		*.*.x0
		*.*.x1		x3 FLTARR that locate the detector plane in aperture coordinates [meters]
		*.*.x2
		*.*.xi		FLTARR of xi locations of pixels on the detector [meters]
		*.*.zeta	FLTARR of zeta locations of pixels on the detector [meters]
		*.*.size	FLTARR [xi,zeta] of detector dimensions [meters]
		*.*.n_xi	INT number of xi pts
		*.*.n_zeta	INT number of zeta pts
		*.type		STR of type (must be spherical)
		*.author	STR name of the author of the info file

	If path points to an info file that doesn't have (on the second line) 'type = planar' then the
	function will RETURN, -1


RESTRICTIONS:
	There are formatting issues with the INFO file.  See /home/mlreinke/idl/genie/data/info/planar_template.info 
	to get a template to enter the data.  Contact the author with questions.

MODIFICATION HISTORY:
	Written by:	ML Reinke: 1/10

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_SPHERICAL_REFL">
<H2>GENPOS_SPHERICAL_REFL</H2></A>
<A HREF="#GENPOS_SPHERICAL_INFO">[Previous Routine]</A>
<A HREF="#GENPOS_UPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_SPHERICAL_REFL

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_UPOS">
<H2>GENPOS_UPOS</H2></A>
<A HREF="#GENPOS_SPHERICAL_REFL">[Previous Routine]</A>
<A HREF="#GENPOS_VOL_COEFS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_UPOS

PURPOSE:
	This function takes a grided detector and grided aperture and
	determines the positions vectors and etendues for all the
	possible connections.

CALLING SEQUENCE:
	result=GENPOS_UPOS(ap_vec,ap_rot,x0,x1,x2,ap_grid,det_grid)

INPUTS:
	ap_vec:		FLTARR [ro, 0.0, zo] where ro and zo is the aperture position
	ap_rot: 	FLTARR [alpha,beta,gamma] set of orientation angles of the aperture [in radians]
	x0:
	x1:		x3 FLTARR locations of the detector's fiducial points in aperture coordinates.
	x2:
	ap_grid:	STRUC grid of aperature subarray centers (use GENPOS_GRID with /center)
	det_grid:	STRUC grid of detector subarray centers (use GENPOS_GRID with /center)

OPTIONAL INPUTS
	rot_matrix:	The output of GENPOS_ROT_MATRIX for ap_rot can
			be input to save computation time if processing multiple detectors

KEYWORD_PARAMETERS:
	debug:		/debug to stop before RETURN

OUTPUTS:
	result:		STRUC containing the position vectors and etendues of the n_ap*n_det different combinations 
			*.upos FLTARR [4,n_ap*n_det] position vectors r1,z1,rt,th] with point 1 being the detector
			*.du   FLTARR [n_ap*n_det] values of the etendue linking the detector and aperature subarray

RESTRICTIONS:
	The aperature and detector grids must be generated using GENPOS_GRID so the ap_grid points will be in the y-z plane
	with the center being the origin.  The det_grid points will be in the xi-zeta plane located by x0,x1 and x3.  The center of
	the grid (input to GENPOS_GRID) should be the center of the detector prior to being subdivided.

PROCEDURE
	See the 'Beyone the Line Integral Approximation' section for info on why this is a useful thing to do.

MODIFICATION HISTORY:
	Written by:	M.L. Reinke June 2006
	6-27-06:	M.L. Reinke: corrected calc of dU to include cosine terms
	8-25-06:	ML Reinke - adjusted call to GENPOS_DBLXYZ2TOK to use detector points as XYZ1 and
                                   aperture as XYZ2
	8-28-06:	ML Reinke - added the ability to handle normally out of bounds psi values
                                   using GENPOS_INVERT_POS

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_VOL_COEFS">
<H2>GENPOS_VOL_COEFS</H2></A>
<A HREF="#GENPOS_UPOS">[Previous Routine]</A>
<A HREF="#GENPOS_XYZ2ALIGN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_VOL_COEFS

PURPOSE:
	This function takes an array of tokamak positions vectors, and their etendues and determines the volume 
	element w/r/t to a user supplied grid.  It is assumed that the inputs are sub-arrays of a single detector channel.

CALLING SEQUENCE:
	result=GENPOS_VOL_COEFS(grid,upos,du)

INPUTS:
	grid:		STRUC boundaries of rectangular pixels.  It's necessary to use the output of GENPOS_GRID (DO NOT use /center)
	upos:		FLTARR of size 4 x m of pos [ro,zo,rt,psi] For planar detectors, use the output of GENPOS_UPOS *.upos
	du:		FLTARR of length m of the differential etendues [m^2 str] for each pos vector in upos.  For planar detectors,
				use the output of GENPOS_UPOS *.du

OPTIONAL INPUTS:
	vol2d:		If vol2d is set to a non-zero variable then it will be filled with the volume 
			information availale in 2D (see optional outputs)
	lhat:		Set lhat to a non-zero named variable and it will be filled with the optional output lhat structure	
	
KEYWORD PARAMETERS:
	phineg:		/phineg changes the sign on the toroidal direction unit vector
	debug:		/debug stops the code in various places
	kdebug:		/kdebug invokes loop_debug and plots for upos[*,k]
	loop_debug:	/loop_debug stops the code during the UPOS loop
	plots:		/plots outputs plots of the grid, intersection points and line of sight.
	contour:	/contour generates a contour plot of the volume elements on the (R,Z) grid input.
	ps:		/ps suppresses calls to windows and allows PS files to be generated
	 		NOTE: There will be UPOS number of plots if this is invoked, so do with care.

OUTPUTS:
	result:		FLTARR of length n x m, where n is the number of grid points and m is the number of upos elements.  The
				values are volumes associated with elements described by grid.  To get the total, assuming upos 
				and du describe one detector, use vol=SUM_ARRAY(result, /i) (SUM_ARRAY is a
				function in MLR_FUNCTIONS which is necessary to run GENPOS)

OPTIONAL OUTPUTS:
	vol2d:		STRUC of the volume information in 2D
			*.vol 	FLTARR [nx,ny] of the volume elements
			*.r   	FLTARR of length nx of the radial grid points (centers)
			*.z   	FLTARR of length ny of the vertical grid points (centers)
	ctime:		FLT ctime will return the total computation time of GENPOS_VOL_COEFS
	lhat:		STRUC of the weighted unit vectors in (r,phi,z).  For each UPOS, dV*unit vector is added at each
			voxel intersection.  See PROCEDURE for info on creating the useful input to GENSPEC functions
			*.r		STRUC of the weighted radial unit vectors and weightings
			*.*.in		FLTARR [n, m] of the weighted radial unit vector going in
			*.*.dvin	FLTARR [n, m] of the volume weightings going in
			*.*.out		FLTARR [n, m] of the weighted radial unit vector coming out
			*.*.dvout	FLTARR [n, m] of the volume weightings coming out
			*.phi		FLTARR [n, m] of the weighted toroidal unit vector
			*.z		FLTARR [n, m] of the weighted vertical unit vector

	IF /ps is used then postscript outputs will be stored in /home/username/idl/plots
		/contour - gpv_genplt_*.ps
		/plots - gpv_grids.ps

PROCEDURE:
	GENPOS_VOL_COEFS must be run for each detector element.  The output of this function need only be calculated once for
	installed detectors and then can be stored for subsequent use in an inversion algorithm.  To model detectors from a
	known/modeled emissivity, the power deposited on a detector can be calculated from these volume estimates as total(vol*emiss)

	The extents of GRID are used to determine bounds in the parameter-l that will intersect the grid (l_min,l_max).  
	These are turned into boundaries in R and Z which are used to create a subset of the R and Z locations of the grid.  
	The intersection points on the grid are found by solving for the parameter-l where the hyperbola definded by POS
	intersects either an R or Z grid location.  The intersection points are then sorted in parameter-l and the volume element
	is added to the corresponding pixel.  dV+=dU/(4pi)*delta_l*sqrt[(R1^2-RT^2)*(1+(tan(psi))^2)].  See 'Beyond the Line
	Integral Approximation' for why this value is useful

	NOTE:   it is up to the end user to show convergance of the volume elements as the aperture and detector meshing
		is increased.

	Like GPV, to form the lhat array that should be stored you must use sum_array to add over all the UPOS vectors.  Then
	divided out the total GPV, limiting to non-zero values, to get the average unit vector at each spatial point.


MODIFICATION HISTORY:
	Written by:	ML Reinke - June 2006
	6-30-06:	ML Reinke - large overhaul in the loop for each POS vector to decrease calculation time
				    intersections are done in parameter-l and (R,Z) points are only calculated
				    when plotting.
	7-31-06:	ML Reinke - adjusted the finding of zgr intersections so that duplicates (line intersects a grid point) are
                                   not counted.
	8-09-06:	ML Reinke - added a flag to contour plot to check to see if there were any volume elements added.  This
                                   allows arrays that have channels off the grid to be contour plotted in a simple loop.
	8-30-06:	ML Reinke - discovered that GPV eats it when psi->!pi/2.0
	8-31-06:	ML Reinke - fixed a bug when i_int[tmp] and j_int[tmp] are computed that made values = -2 when slightly over/under
				    the  max/min of the grid size. Values are now forced to edge if over the edge.
	8-08-07:	ML Reinke - added the lhat optional output to calculate weighted unit vectors for GENSPEC
	8-14-07:	ML Reinke - changed the formatting of lhat.r to be a sub structure for inward and outward views.
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_XYZ2ALIGN">
<H2>GENPOS_XYZ2ALIGN</H2></A>
<A HREF="#GENPOS_VOL_COEFS">[Previous Routine]</A>
<A HREF="#GENPOS_XYZ2TOK">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_XYZ2ALIGN

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="GENPOS_XYZ2TOK">
<H2>GENPOS_XYZ2TOK</H2></A>
<A HREF="#GENPOS_XYZ2ALIGN">[Previous Routine]</A>
<A HREF="#GRID_VES">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GENPOS_XYZ2TOK

CALLING SEQUENCE:
	result=GENPOS_XYZ2TOK(ap_vec,xyz_vec,rot)

PURPOSE:
	This function generates the tangency radius (R_t) and
	declination angle (psi) given a single point in aperature
	coordinates and assumes the aperate is the 2nd point.

INPUTS:
	ap_vec:		FLTARR [ro, 0.0, zo] where ro and zo is the aperture position
	xyz_vec:	FLTARR [x,y,z] location of a point in aperature coordinates
	rot: 		FLTARR rotation matrix generated using GENPOS_ROT_MATRIX

OUTPUTS:
	result:		FLTARR [R_t, psi]

OPTIONAL OUTPUTS:
	bigXYZ_vec:	FLTARR of the XYZ vector of the input xyz_vec
	cyl_vec:	FLTARR of the cylindrical vector of the input xyz_vec

PROCEDURE:
	This function generates the XYZ positions of xyz_vec and forms
	its RZ position.  The cosphi is generated assume the aperture
	is at theta = 0 and has RZ of the aperature.  Then GENPOS_CYL2TOK
	to find R_t and psi.

MODFICATION HISTORY:
	Written by:	ML Reinke - June 2006
	8-25-06:	ML Reinke - changed it so that call to GENPOS_CYL2TOK uses detector as
                                   rz1 and aperture as rz2

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="GRID_VES">
<H2>GRID_VES</H2></A>
<A HREF="#GENPOS_XYZ2TOK">[Previous Routine]</A>
<A HREF="#LINE_PLANE_INT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	GRID_VES

PURPOSE:
	This function returns a grid of arbitrary density that effectively
	describes the Alcator C-Mod geometry.

CALLING SEQUENCE:
	result=GRID_VES()

OPTIONAL INPUTS:
	nx:	INT number of grids in the radial direction 	DEFAULT: 10
	ny:	INT number of grids in the vertical direction 	DEFAULT: 10
	rrange:	FLTARR of the radial range DEFAULT [0.425, 0.925]
	zrange: FLTARR of the z range DEFAULT [-0.45,0.45]

KEYWORD PARAMETERS:
	center:		/center is sent to GENPOS_GRID
	div:		/div sets the grid to parameters that describe the divertor
			The rrange and zrange optional inputs do not work with divertor

OUTPUTS:
	Output formatted the same as GENPOS_GRID.  See it's helpfile

PROCEDURE:
	This is simply a call to GENPOS_GRID with hard-coded bounds
	result=GENPOS_GRID(0.5,0.9,[nx,ny],xo=0.675,center=center)

MODIFICATION HISTORY:
	Written by:	ML Reinke - Summer 2006
	1-20-07:	ML Reinke - added the zrange and rrange optional inputs
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_utility.pro)</STRONG><P>
<HR>
 
<A NAME="LINE_PLANE_INT">
<H2>LINE_PLANE_INT</H2></A>
<A HREF="#GRID_VES">[Previous Routine]</A>
<A HREF="#XRAY_TOMO_INFO">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	LINE_PLANE_INT

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="XRAY_TOMO_INFO">
<H2>XRAY_TOMO_INFO</H2></A>
<A HREF="#LINE_PLANE_INT">[Previous Routine]</A>
<A HREF="#XRAY_TOMO_POS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
UNCTION is_xtomo_emiss,shot
mdsopen,'xtomo',shot
dummy=mdsvalue('\XTOMO::TOP.RESULTS.CORE.CONFIG:EPS',/quiet,status=status)
mdsclose,'xtomo',shot
IF status THEN output=1 ELSE output=0
RETURN,output
ND

UNCTION is_xtomo_asym,shot
mdsopen,'xtomo',shot
dummy=mdsvalue('dim_of(\XTOMO::TOP.RESULTS.CORE:EMISS,5)',/quiet,status=status)
IF status THEN RETURN,1 ELSE RETURN,0
ND

NAME:
	XRAY_TOMO_INFO

PURPOSE:
	This function loads geometry data from the tree to create an planar INFO file for use with GENPOS.

CALLING SEQUENCE:
	result=XRAY_TOMO_INFO(array)

INPUTS:
	array:		INT of the array number (see procedure)

OPTIONAL INPUTS:
	shot:		LONG of the shot number to load from DEFAULT: -1

KEYWORD PARAMETERS:
	debug:		/debug stops the code before the output is returned

OUTPUTS:
	result:		STRUC in the INFO file format.  (See GENPOS help)
	
PROCEDURE:
	Data is loaded from the \MHD::TOP.XTOMO.GEOMETRY node.  The array value uses the tree
	notation.
			1 - core top
			2 - edge top
			3 - core outboard
			4 - edge outboard	

MODIFICATION HISTORY:
	Written by:	ML Reinke - Spring 2006

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="XRAY_TOMO_POS">
<H2>XRAY_TOMO_POS</H2></A>
<A HREF="#XRAY_TOMO_INFO">[Previous Routine]</A>
<A HREF="#XTOMO_CORE_WRITE2TREE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	XRAY_TOMO_POS
	
PURPOSE:
	This function uses XRAY_TOMO_INFO AND GENPOS_PLANAR2POS to find the pos vector and etendue for one or more arrays.

CALLING SEQUENCE:
	result=XRAY_TOMO_POS()

KEYWORD PARAMETERS:
	reform:		/reform will run GENPOS_POS_REFORM, necessary for useful POS data from ARRAY 1.  RZBND=[0.44,1.0,0.4,-0.4]

OPTIONAL INPUTS:
	shot:		LONG shot number DEFAULT: -1
	array:		INT  array number [1,2,3,4] DEFAULT: 1

OUTPUTS:
	result:		FLTARR [4,n_ch] of the POS vector for the array(s)

OPTIONAL OUTPUTS:
	etendue:	FLTARR [n_ch] of the etendue for each channel [m^2-str]
	rz_ap:		FLTARR [Ro,Zo] of the aperture location

MODIFICATION HISTORY:
	Written by:	ML Reinke - Spring 2006
	1-31-08:	ML Reinke - added the reform keyword [use with ARRAY 1]

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="XTOMO_CORE_WRITE2TREE">
<H2>XTOMO_CORE_WRITE2TREE</H2></A>
<A HREF="#XRAY_TOMO_POS">[Previous Routine]</A>
<A HREF="#XTOMO_GET_GOOD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	XTOMO_CORE_WRITE2TREE

PURPOSE:
	This procedure calculates emissivity and brightness data and inserts it into the tree for the core xray arrays.
	Flux surface symmetry is assumed (erroneously past 1st order) and the resulting brightness checks can be used to see
	what type of asymmetry is present (in/out or up/down) so further analysis can be done.

CALLING SEQUENCE
	XTOMO_CORE_WRITE2TREE,shot

INPUTS:
	shot:		LONG	shot number

OPTIONAL INPUTS:
	del_i:		INT	number of points to average brightness over before inversion DEFAULT: from TREE
	good:		INTARR	of 1's and 0's describing good channels DEFAULT: from TREE
	eps:		FLT	smoothing weighting factor DEFAULT: see CALC_XTOMOCORE_EMISS_DATA
	eta:		FLT	edge zero weighting factor DEFAULT: see CALC_XTOMOCORE_EMISS_DATA
	n_rho		INT	number of rho points DEFAULT: see CALC_XTOMOCORE_EMISS_DATA
	rho_vec:	FLTARR	values of the rho points to do the inversion on DEFAULT: see CALC_XTOMOCORE_EMISS_DATA
	n_s:		INT	number of points to divide line of sight into for calculating VOXEL matrix
	tr:		FLTARR 	[t_low,t_high] of the time interval to do inversions [sec] DEFAULT: from TREE
	etree:		STRING	of the EFIT tree to use for inversion [DEFAULT: ANALYSIS]

KEYWORD PARAMETERS:
	no_emiss:	/no_emiss does not calculate emissivity but just stores BRIGHT, DEL_I and GOOD
	debug:		/debug stops the code before the end for debugging purposes

OUTPUTS:
	All data is stored to the tree in array specific nodes in \XTOMO::TOP.RESULTS.ARRAY_X
		\XTOMO::TOP.RESULTS.CORE:BRCHK - brightness checks [W/m^2]
		\XTOMO::TOP.RESULTS.CORE:BRIGHT - brightness [W/m^2]
		\XTOMO::TOP.RESULTS.CORE:EMISS - emissivity [W/m^3]
		\XTOMO::TOP.RESULTS.CORE:RMAJ - major radius values for the inversion (time evolving) [m]
		\XTOMO::TOP.RESULTS.CORE.CONFIG:DEL_I
		\XTOMO::TOP.RESULTS.CORE.CONFIG:EPS
		\XTOMO::TOP.RESULTS.CORE.CONFIG:ETA
		\XTOMO::TOP.RESULTS.CORE.CONFIG:GOOD
		\XTOMO::TOP.RESULTS.CORE.CONFIG:N_S
		\XTOMO::TOP.RESULTS.CORE.CONFIG:TR

PROCEDURE:
	If /no_emiss is used, then the brightness data will be stored where the GOOD=0 channels will be forced to zero.  When the emissivity
	is stored as well, then the brightness data has the bad channels removed.  Also, since EFIT is required for the inversion, the brightness
	and emissivity data is only run between the first and last EFIT times and the datasets are truncated.

MODIFICATION HISTORY:
	Written by:	ML Reinke - 1/31/08
	2/11		ML Reinke - updated to calc the m=1 sine and cosine terms
	4/6/11		ML Reinke - updated to calc and store the m=2 cosine term
	1/10/12		ML Reinke - added array5 for shots > 1111201001
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="XTOMO_GET_GOOD">
<H2>XTOMO_GET_GOOD</H2></A>
<A HREF="#XTOMO_CORE_WRITE2TREE">[Previous Routine]</A>
<A HREF="#XTOMO_WRITE2TREE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	XTOMO_GET_GOOD

PURPOSE:
	This function loads the GOOD vector for use with the brightness profiles.

CALLING SEQUENCE:
	result=XTOMO_GET_GOOD(array)

INPUTS:
	array:	INT of the array [1,2,3,4]

OPTIONAL INPUTS:
	shot:	LONG of the shot number DEFAULT: -1

OUTPUTS:
	result:	INTARR [n_ch] of 1's and 0's showing which channels are good

PROCEDURE:
	Currently this is hardcoded...staytuned.

MODIFICATION HISTORY:
	Written by:	ML Reinke - 12/07
	1-30-07:	ML Reinke - updated good for array 3
	7-31-07:	ML Reinke - updated shot evolving channel maps for FY05 and FY06

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="XTOMO_WRITE2TREE">
<H2>XTOMO_WRITE2TREE</H2></A>
<A HREF="#XTOMO_GET_GOOD">[Previous Routine]</A>
<A HREF="#_GENPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	XTOMO_WRITE2TREE

PURPOSE:
	This procedure calculates emissivity and brightness data and inserts it into the tree

CALLING SEQUENCE
	XTOMO_WRITE2TREE,shot,array

INPUTS:
	shot:		LONG	shot number
	array:		INT	array number [2,4]

OPTIONAL INPUTS:
	del_i:		INT	number of points to average brightness over before inversion DEFAULT: 5
	good:		INTARR	of 1's and 0's describing good channels DEFAULT: see CALC_XTOMO_EMISS_DATA
	eps:		FLT	smoothing weighting factor DEFAULT: 1.0
	eta:		FLT	edge zero weighting factor DEFAULT: 1.0	
	n_rho		INT	number of rho points DEFAULT: see CALC_XTOMO_EMISS_DATA
	rho_vec:	FLTARR	values of the rho points to do the inversion on DEFAULT: see CALC_XTOMO_EMISS_DATA
	n_s:		INT	number of points to divide line of sight into for calculating VOXEL matrix

KEYWORD PARAMETERS:
	no_emiss:	/no_emiss does not calculate emissivity but just stores BRIGHT, DEL_I and GOOD
	debug:		/debug stops the code before the end for debugging purposes

OUTPUTS:
	All data is stored to the tree in array specific nodes in \XTOMO::TOP.RESULTS.ARRAY_X
		\XTOMO::TOP.RESULTS.ARRAY_X:BRCHK - brightness checks [W/m^2]
		\XTOMO::TOP.RESULTS.ARRAY_X:BRIGHT - brightness [W/m^2]
		\XTOMO::TOP.RESULTS.ARRAY_X:EMISS - emissivity [W/m^3]
		\XTOMO::TOP.RESULTS.ARRAY_X:RMAJ - major radius values for the inversion (time evolving)
		\XTOMO::TOP.RESULTS.ARRAY_X:RTMID - outboard midplane values for the brightness and brightness check
		\XTOMO::TOP.RESULTS.ARRAY_X.CONFIG:DEL_I
		\XTOMO::TOP.RESULTS.ARRAY_X.CONFIG:EPS
		\XTOMO::TOP.RESULTS.ARRAY_X.CONFIG:ETA
		\XTOMO::TOP.RESULTS.ARRAY_X.CONFIG:GOOD
		\XTOMO::TOP.RESULTS.ARRAY_X.CONFIG:N_S
		\XTOMO::TOP.RESULTS.ARRAY_X.CONFIG:RHO_VEC

PROCEDURE:
	If /no_emiss is used, then the brightness data will be stored where the GOOD=0 channels will be forced to zero.  When the emissivity
	is stored as well, then the brightness data has the bad channels removed.  Also, since EFIT is required for the inversion, the brightness
	and emissivity data is only run between the first and last EFIT times and the datasets are truncated.

MODIFICATION HISTORY:
	Written by:	ML Reinke - 1/22/08

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos_xraytomo.pro)</STRONG><P>
<HR>
 
<A NAME="_GENPOS">
<H2>_GENPOS</H2></A>
<A HREF="#XTOMO_WRITE2TREE">[Previous Routine]</A>
<A HREF="#_TUTORIAL  - CREATING A VOLUME WEIGHTING VECTOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	_GENPOS

PURPOSE:
	The GENPOS_* suite of procedures and functions are the
	application of formulas and methods in 'General Equations for
	Radiometry in Tokamak Plasmas' for pinhole cameras.  Due to
	the specifics of geometry contained in these functions it is
	highly recommened to obtain a copy of this paper while using
	these functions since its FIGURES will help dramatically

	Version 1.0 - original 
	Version 1.1 - Updated speed on GENPOS_VOL_COEFS
	Version 1.2 - Added GENPOS_PLANAR tools
	Version 1.3 - Added the matrix inversion tools

MODIFICATION HISTORY:
	Version 1.3
	ML Reinke 
	July 2006
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
<A NAME="_TUTORIAL  - CREATING A VOLUME WEIGHTING VECTOR">
<H2>_TUTORIAL  - CREATING A VOLUME WEIGHTING VECTOR</H2></A>
<A HREF="#_GENPOS">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	_TUTORIAL  - CREATING A VOLUME WEIGHTING VECTOR

PURPOSE:

	The volume weightings are referred to as GPV (short for GENPOS Volumes) throughout
	this program.  These are generated for a given grid defined by using GENPOS_GRID.  The
	center points of this grid are found using the /center keyword in GENPOS_GRID.  For
	C-Mod, the GRID_VES function can be used to generate grides that cover most of the
	tokamak cross-section.  If the emissivity (Power/Volume - NO STERRADIANS!) is known at
	each of these grid centers, then the total power desposited onto the dector for which
	the GPV was calculated is the sum of the GPV times the emissivity at every grid point.
	Note that when making such sums, it is quicker to use WHERE(GPV NE 0) to isolate
	elements from which emission is actually collected.

	TEST_SCRIPT:					;assume upos and du are given
	nx=100
	ny=100
	ves_grid=GRID_VES(nx=nx, ny=ny) 		; grid for input to GENPOS_VOL_COEFS
	ves_cent=GRID_VES(nx=nx, ny=ny, /center)	; 100x100 (R,Z) points of the grid centers for general use
	gpv_raw=GENPOS_VOL_COEFS(ves_grid,upos,du)	; generate a raw GPV given a upos array [4,n] and du [n] vector
	gpv=SUM_ARRAY(gpv_raw,/i)			; creates the GPV array of intereste 
	GENPOS_GPV2CONTOUR,gpv,ves_cent			; make a contour plot of the gpv


</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/GENPOS/genpos.pro)</STRONG><P>
<HR>
 
</body>
</html>
