<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>GENIE - utilities</TITLE>
</head>
 
<body>
<H1>GENIE - utilities</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Thu Jun  7 14:32:58 2012.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#ARRAY_SLICE">ARRAY_SLICE</A>
<LI><A HREF="#AVEARRAY">AVEARRAY</A>
<LI><A HREF="#BINARRAY">BINARRAY</A>
<LI><A HREF="#DAY2RUN">DAY2RUN</A>
<LI><A HREF="#EQ_STR">EQ_STR</A>
<LI><A HREF="#FIXARRAY">FIXARRAY</A>
<LI><A HREF="#FREQSPEC">FREQSPEC</A>
<LI><A HREF="#FS_PLOT">FS_PLOT</A>
<LI><A HREF="#IBOUND">IBOUND</A>
<LI><A HREF="#INTERP_VEC_REFORM">INTERP_VEC_REFORM</A>
<LI><A HREF="#IONGYRO">IONGYRO</A>
<LI><A HREF="#IPT">IPT</A>
<LI><A HREF="#IS_FILE">IS_FILE</A>
<LI><A HREF="#IVEC">IVEC</A>
<LI><A HREF="#LOCALMAXMIN">LOCALMAXMIN</A>
<LI><A HREF="#LOGNAME">LOGNAME</A>
<LI><A HREF="#MAKE">MAKE</A>
<LI><A HREF="#MAXLOC">MAXLOC</A>
<LI><A HREF="#MINLOC">MINLOC</A>
<LI><A HREF="#MLR_FUNCTIONS">MLR_FUNCTIONS</A>
<LI><A HREF="#MPFIT">MPFIT</A>
<LI><A HREF="#MPFITFUN">MPFITFUN</A>
<LI><A HREF="#N">N</A>
<LI><A HREF="#N2G">N2G</A>
<LI><A HREF="#NUM2STR">NUM2STR</A>
<LI><A HREF="#OPENWIN">OPENWIN</A>
<LI><A HREF="#REMOUT">REMOUT</A>
<LI><A HREF="#RUNS">RUNS</A>
<LI><A HREF="#SAMEAN">SAMEAN</A>
<LI><A HREF="#SUB_BL">SUB_BL</A>
<LI><A HREF="#SUM_ARRAY">SUM_ARRAY</A>
<LI><A HREF="#TVZOOM">TVZOOM</A>
<LI><A HREF="#VALIDSHOTS">VALIDSHOTS</A>
<LI><A HREF="#VESSEL_PLOT">VESSEL_PLOT</A>
<LI><A HREF="#WAVESTATS">WAVESTATS</A>
<LI><A HREF="#WCLOSE">WCLOSE</A>
<LI><A HREF="#WIN_SAVE">WIN_SAVE</A>
<LI><A HREF="#WRESET">WRESET</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="ARRAY_SLICE">
<H2>ARRAY_SLICE</H2></A>
<A HREF="#AVEARRAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	ARRAY_SLICE

PURPOSE:
	This function returns the slice along io or jo of array

CALLING SEQUENCE:
	result=ARRAY_SLICE(array, ivec,jvec)

INPUTS:
	array:		2D array of any format
	ivec:		1D i scaling of array
	jvec:		1D j scaling of array

OPTIONAL INPUTS:
	io:		Use io=# (FLT) as a number in ivec to take the slice
	jo:		Use jo=# (FLT) as a number in jvec to take the slice

OUTPUTS:
	result:		1D vector of array interpolated at io or jo
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="AVEARRAY">
<H2>AVEARRAY</H2></A>
<A HREF="#ARRAY_SLICE">[Previous Routine]</A>
<A HREF="#BINARRAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	AVEARRAY

PURPOSE:
	This function allows you to take average cuts out of 1D and 2D arrays using values of scaling
	vectors (such as time or space for emissivity profiles).

CALLING SEQUENCE:
	result=AVEARRAY(array,x,x1,x2)


</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="BINARRAY">
<H2>BINARRAY</H2></A>
<A HREF="#AVEARRAY">[Previous Routine]</A>
<A HREF="#DAY2RUN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	BINARRAY

PURPOSE:
	This program bins the input array in defined del_i,del_j bins and reforms the array and i,j scalings

CALLING SEQUENCE:
	BINARRAY,array,ivec,jvec,del_i,del_j,new_array,new_ivec,new_jvec

INPUTS:
	array:		2D array of values
	ivec:		i-scaling of array
	jvec:		j-scaling of array
	del_i:		number of i points per bin
	del_j:		number of j points per bin

OUTPUTS:
	new_array:	Binned 2D array
	new_ivec:	Binned 1D vector
	new_jvec:	Binned 1D vector
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="DAY2RUN">
<H2>DAY2RUN</H2></A>
<A HREF="#BINARRAY">[Previous Routine]</A>
<A HREF="#EQ_STR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME: 
	DAY2RUN

PURPOSE:
	This function checks the system clock and turns the date into a run number 
	based on a SYSTIME call.  Run number is Alcator type.

CALLING SEQUENCE:
	result=DAY2RUN()

OUTPUTS:
	result: INT run number (ie ... 1050426 for April 26,2005) 

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="EQ_STR">
<H2>EQ_STR</H2></A>
<A HREF="#DAY2RUN">[Previous Routine]</A>
<A HREF="#FIXARRAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	 EQ_STR

PURPOSE: 
	This function determines whether 2 structurs are completely equal from header tags
	right down to type and value.

CALLING SEQUENCE:
	result=EQ_STR(str1,str2)

INPUTS:
	str1,str2:	two generically formatted structurs

OUTPUTS:
	result:		0 (false) or 1 (true) depending on the comparison

RESTRICTIONS:
	This is untested on complicated things like pointers and object references but should
	work for arrays in structures and complex value numbers w/ more than one element 

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="FIXARRAY">
<H2>FIXARRAY</H2></A>
<A HREF="#EQ_STR">[Previous Routine]</A>
<A HREF="#FREQSPEC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	FIXARRAY

PURPOSE:
	This function reforms the input array including only non-zero elements (rows/columns for 2D array)
	of the vector good.  If array is 2D then the length of good should match one dimension of array.

CALLING SEQUENCE:
	result=FIXARRAY(array,good)

RESTRICTIONS
	array cannot be 2D and (n x n)

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="FREQSPEC">
<H2>FREQSPEC</H2></A>
<A HREF="#FIXARRAY">[Previous Routine]</A>
<A HREF="#FS_PLOT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	FREQSPEC
	
PURPOSE:
	This program is a quick and dirty way to plot frequency spectra to look for things like noise.  I would
	advise NOT using it for quantitative data analysis.

CALLING SEQUENCE
	FREQSPEC,v,t

INPUTS:
	v:	FLTARR	of the the signal
	t:	FLTARR	of the time 

OPTIONAL INPUTS:
	w:	INT	number of points to smooth frequency spectra before plotting DEFAULT: 0
	tr:	FLTARR	[t1,t2] of the time region to use DEFAULT: all time points
	fr:	FLTARR	[f1,f2]	of the frequence range to plot DEFAULT: [1.0, Nyquist]
	pr:	FLTARR	[p1,p2] of the fractional power range to plot

KEYWORD PARAMETERS:
	debug	/debug will stop the code before the return statement

OUTPUTS:
	Outputs are plotted to x-windows.
		WINDOW-0: Time history of the signal trace
		WINDOW-1: Frequency spectrum of the signal trace

MODIFICATION HISTORY:
	Written by:	ML Reinke - 12/07

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="FS_PLOT">
<H2>FS_PLOT</H2></A>
<A HREF="#FREQSPEC">[Previous Routine]</A>
<A HREF="#IBOUND">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	FS_PLOT

PURPOSE:
	This procedure OPLOTS flux surfaces, presumabley onto a window where VESSEL_PLOT has been called.

CALLING SEQUENCE
	FS_PLOT,shot,time

INPUTS:
	shot:	LONG	shot number
	time:	FLT	time point [sec]

MODIFICATION HISTORY:
	6/18/11		M.L. Reinke - modified to allow non-ANALYSIS EFIT's to be used
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="IBOUND">
<H2>IBOUND</H2></A>
<A HREF="#FS_PLOT">[Previous Routine]</A>
<A HREF="#INTERP_VEC_REFORM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	IBOUND

PURPOSE:
	This function calculates the bounding incides of vec that surround val

CALLING SEQUENCE:
	result=IBOUND(vec,val)

INPUTS:
	vec:		1D vector
	val:		just a number folks

OUTPUTS:
	result:		bounding indices [i0,i1] of val. -1 if val is outside vec
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="INTERP_VEC_REFORM">
<H2>INTERP_VEC_REFORM</H2></A>
<A HREF="#IBOUND">[Previous Routine]</A>
<A HREF="#IONGYRO">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	INTERP_VEC_REFORM

PURPOSE:
	This function reforms a vector of values according to the indices of a
	given scaling vector, which usually be for a 2D array.  This is a preprocessing
	utility for INTERPOLATE.  See the help file on INTERPOLATE to understand why this
	is useful

CALLING SEQUENCE:
	result=INTERP_VEC_REFROM(scale_vec,val_vec)

INPUTS:
	scale_vec:	scaling vector of an array
	val_vec:	vector of points of interest for use in INTERPOLATE

OUTPUTS:
	result:		interpolated index values of scale_vec for the values in val_vec
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="IONGYRO">
<H2>IONGYRO</H2></A>
<A HREF="#INTERP_VEC_REFORM">[Previous Routine]</A>
<A HREF="#IPT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	IONGYRO

PURPOSE:
	This function returns the ion gyro radius rho=v_th/Omega

CALLING SEQUENCE:
	result=IONGYRO(z,Ti,B)

INPUTS:
	z	INT charge of ion
	Ti	FLT ion temperature [in eV]
	B	FLT magnetic field [in Tesla]

OPTIONAL INPUTS:
	zstr	STR of the element symbol.  Use this to specify the element when not fully stripped ion
		    or to choose different hydrogenic species.

OUTPUTS:
	result:	FLT of the ion gyro radius in meters	

MODIFICATION HISTORY:
	Written by:	ML Reinke, April 2nd, 2007
	
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="IPT">
<H2>IPT</H2></A>
<A HREF="#IONGYRO">[Previous Routine]</A>
<A HREF="#IS_FILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	IPT

PURPOSE:
	This function calculates the point, i, in the input vector that val is closest to.

CALLING SEQUENCE:
	result=IPT(vec,val)

INPUTS:
	vec:		1D vector
	val:		just a number folks

OUTPUTS:
	result:		index, i, of vec
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="IS_FILE">
<H2>IS_FILE</H2></A>
<A HREF="#IPT">[Previous Routine]</A>
<A HREF="#IVEC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	IS_FILE

PURPOSE:
	This function uses a CHKSUM call to Linux and feeds back on the error to see if a
	file exists or not.

CALLING SEQUENCE:
	result=IS_FILE(filename)

INPUTS:
	filename:	STR full path from root to where file is located

KEYWORD_PARAMETERS
	size:		/size will make the output the size of the file in bytes

OUTPUTS:
	result:		INT 0 or 1 depending on the file existing (see /size)

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="IVEC">
<H2>IVEC</H2></A>
<A HREF="#IS_FILE">[Previous Routine]</A>
<A HREF="#LOCALMAXMIN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	IVEC

PURPOSE:
	This function makes repeated calls to IPT so that a vector of values can be input

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="LOCALMAXMIN">
<H2>LOCALMAXMIN</H2></A>
<A HREF="#IVEC">[Previous Routine]</A>
<A HREF="#LOGNAME">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	LOCALMAXMIN

PURPOSE:
	This function calculates the max and min of array within a defined x,y range.

CALLING SEQUENCE:
	result=LOCALMAXMIN(array,x,y,xrange,yrange)

INPUTS:
	array:		2D array of values
	x:		i-scaling of array
	y:		j-scaling of array
	xrange:		[x0,x1] x bounds for sub array
	yrange:		[y0,y1] y bounds for sub array

OUTPUTS:
	result:		[min,max]
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="LOGNAME">
<H2>LOGNAME</H2></A>
<A HREF="#LOCALMAXMIN">[Previous Routine]</A>
<A HREF="#MAKE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	LOGNAME

PURPOSE:
	This function is just a time save for calling the linux shell command logname to
	check and see who's using the code

CALLING SEQUENCE:
	result=LOGNAME()

OUTPUTS:
	result:		STR of the current logname
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="MAKE">
<H2>MAKE</H2></A>
<A HREF="#LOGNAME">[Previous Routine]</A>
<A HREF="#MAXLOC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	MAKE 
	
PURPOSE:
	This function creates a FLTARR of a specified number of points
	inclusively between two specificed endpoints.  Really it just
	saves me from having to remember the one line way to do this
	using FINDGEN.  It's also a port of the IGOR PRO syntax for
	doing the same thing.

CALLING SEQUENCE:
	output=make(a,b,n)

INPUTS:
	a:	FLT lower bound
	b:	FLT upper bound
	n:	INT number of data points

OUTPUTS:
	output:	FLTARR of length n with evenly spaced points between (a,b) including
		both a and b.

MODIFICATION HISTORY:
	Written by:	ML Reinke, Nov, 2005
	
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="MAXLOC">
<H2>MAXLOC</H2></A>
<A HREF="#MAKE">[Previous Routine]</A>
<A HREF="#MINLOC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	MAXLOC

PURPOSE:
	This function calculates the i-point of the maximum  in the input data

CALLING SEQUENCE:
	result=MAXLOC(data)

INPUTS:
	data:	Can be 1D or 2D array of any values

OUTPUTS:
	result:		i, for 1D data and [i,j] for 2D data
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="MINLOC">
<H2>MINLOC</H2></A>
<A HREF="#MAXLOC">[Previous Routine]</A>
<A HREF="#MLR_FUNCTIONS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	MINLOC

PURPOSE:
	This function calculates the i-point of the minimum in the input data

CALLING SEQUENCE:
	result=MINLOC(data)

INPUTS:
	data:	Can be 1D or 2D array of any values

OUTPUTS:
	result:		i, for 1D data and [i,j] for 2D data
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="MLR_FUNCTIONS">
<H2>MLR_FUNCTIONS</H2></A>
<A HREF="#MINLOC">[Previous Routine]</A>
<A HREF="#MPFIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	MLR_FUNCTIONS

VERSION:
	Version 2.5
	1-24-07
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="MPFIT">
<H2>MPFIT</H2></A>
<A HREF="#MLR_FUNCTIONS">[Previous Routine]</A>
<A HREF="#MPFITFUN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   MPFIT

 AUTHOR:
   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770
   craigm@lheamail.gsfc.nasa.gov
   UPDATED VERSIONs can be found on my WEB PAGE: 
      http://cow.physics.wisc.edu/~craigm/idl/idl.html

 PURPOSE:
   Perform Levenberg-Marquardt least-squares minimization (MINPACK-1)

 MAJOR TOPICS:
   Curve and Surface Fitting

 CALLING SEQUENCE:
   parms = MPFIT(MYFUNCT, start_parms, FUNCTARGS=fcnargs, NFEV=nfev,
                 MAXITER=maxiter, ERRMSG=errmsg, NPRINT=nprint, QUIET=quiet, 
                 FTOL=ftol, XTOL=xtol, GTOL=gtol, NITER=niter, 
                 STATUS=status, ITERPROC=iterproc, ITERARGS=iterargs,
                 COVAR=covar, PERROR=perror, BESTNORM=bestnorm,
                 PARINFO=parinfo)

 DESCRIPTION:

  MPFIT uses the Levenberg-Marquardt technique to solve the
  least-squares problem.  In its typical use, MPFIT will be used to
  fit a user-supplied function (the "model") to user-supplied data
  points (the "data") by adjusting a set of parameters.  MPFIT is
  based upon MINPACK-1 (LMDIF.F) by More' and collaborators.

  For example, a researcher may think that a set of observed data
  points is best modelled with a Gaussian curve.  A Gaussian curve is
  parameterized by its mean, standard deviation and normalization.
  MPFIT will, within certain constraints, find the set of parameters
  which best fits the data.  The fit is "best" in the least-squares
  sense; that is, the sum of the weighted squared differences between
  the model and data is minimized.

  The Levenberg-Marquardt technique is a particular strategy for
  iteratively searching for the best fit.  This particular
  implementation is drawn from MINPACK-1 (see NETLIB), and seems to
  be more robust than routines provided with IDL.  This version
  allows upper and lower bounding constraints to be placed on each
  parameter, or the parameter can be held fixed.

  The IDL user-supplied function should return an array of weighted
  deviations between model and data.  In a typical scientific problem
  the residuals should be weighted so that each deviate has a
  gaussian sigma of 1.0.  If X represents values of the independent
  variable, Y represents a measurement for each value of X, and ERR
  represents the error in the measurements, then the deviates could
  be calculated as follows:

    DEVIATES = (Y - F(X)) / ERR

  where F is the analytical function representing the model.  You are
  recommended to use the convenience functions MPFITFUN and
  MPFITEXPR, which are driver functions that calculate the deviates
  for you.  If ERR are the 1-sigma uncertainties in Y, then

    TOTAL( DEVIATES^2 ) 

  will be the total chi-squared value.  MPFIT will minimize the
  chi-square value.  The values of X, Y and ERR are passed through
  MPFIT to the user-supplied function via the FUNCTARGS keyword.

  Simple constraints can be placed on parameter values by using the
  PARINFO keyword to MPFIT.  See below for a description of this
  keyword.

  MPFIT does not perform more general optimization tasks.  See TNMIN
  instead.  MPFIT is customized, based on MINPACK-1, to the
  least-squares minimization problem.

 USER FUNCTION

  The user must define a function which returns the appropriate
  values as specified above.  The function should return the weighted
  deviations between the model and the data.  For applications which
  use finite-difference derivatives -- the default -- the user
  function should be declared in the following way:

    FUNCTION MYFUNCT, p, X=x, Y=y, ERR=err
     ; Parameter values are passed in "p"
     model = F(x, p)
     return, (y-model)/err
    END

  See below for applications with analytical derivatives.

  The keyword parameters X, Y, and ERR in the example above are
  suggestive but not required.  Any parameters can be passed to
  MYFUNCT by using the FUNCTARGS keyword to MPFIT.  Use MPFITFUN and
  MPFITEXPR if you need ideas on how to do that.  The function *must*
  accept a parameter list, P.
  
  In general there are no restrictions on the number of dimensions in
  X, Y or ERR.  However the deviates *must* be returned in a
  one-dimensional array, and must have the same type (float or
  double) as the input arrays.

  User functions may also indicate a fatal error condition using the
  ERROR_CODE common block variable, as described below under the
  MPFIT_ERROR common block definition (by setting ERROR_CODE to a
  number between -15 and -1).

 ANALYTIC DERIVATIVES
 
  In the search for the best-fit solution, MPFIT by default
  calculates derivatives numerically via a finite difference
  approximation.  The user-supplied function need not calculate the
  derivatives explicitly.  However, if you desire to compute them
  analytically, then the AUTODERIVATIVE=0 keyword must be passed.  As
  a practical matter, it is often sufficient and even faster to allow
  MPFIT to calculate the derivatives numerically, and so
  AUTODERIVATIVE=0 is not necessary.

  Also, the user function must be declared with one additional
  parameter, as follows:

    FUNCTION MYFUNCT, p, dp, X=x, Y=y, ERR=err
     model = F(x, p)
     
     if n_params() GT 1 then begin
       ; Compute derivatives
       dp = make_array(n_elements(x), n_elements(p), value=x(0)*0)
       for i = 0, n_elements(p)-1 do $
         dp(*,i) = FGRAD(x, p, i)
     endif
    
     return, (y-model)/err
    END

  where FGRAD(x, p, i) is a user function which must compute the
  derivative of the model with respect to parameter P(i) at X.  When
  finite differencing is used for computing derivatives (ie, when
  AUTODERIVATIVE=1), the parameter DP is not passed.  Therefore
  functions can use N_PARAMS() to indicate whether they must compute
  the derivatives or not.

  Derivatives should be returned in the DP array. DP should be an m x
  n array, where m is the number of data points and n is the number
  of parameters.  dp(i,j) is the derivative at the ith point with
  respect to the jth parameter.  
  
  The derivatives with respect to fixed parameters are ignored; zero
  is an appropriate value to insert for those derivatives.  Upon
  input to the user function, DP is set to a vector with the same
  length as P, with a value of 1 for a parameter which is free, and a
  value of zero for a parameter which is fixed (and hence no
  derivative needs to be calculated).  This input vector may be
  overwritten as needed.

  If the data is higher than one dimensional, then the *last*
  dimension should be the parameter dimension.  Example: fitting a
  50x50 image, "dp" should be 50x50xNPAR.
  
 CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD

  The behavior of MPFIT can be modified with respect to each
  parameter to be fitted.  A parameter value can be fixed; simple
  boundary constraints can be imposed; limitations on the parameter
  changes can be imposed; properties of the automatic derivative can
  be modified; and parameters can be tied to one another.

  These properties are governed by the PARINFO structure, which is
  passed as a keyword parameter to MPFIT.

  PARINFO should be an array of structures, one for each parameter.
  Each parameter is associated with one element of the array, in
  numerical order.  The structure can have the following entries
  (none are required):
  
     .VALUE - the starting parameter value (but see the START_PARAMS
              parameter for more information).
  
     .FIXED - a boolean value, whether the parameter is to be held
              fixed or not.  Fixed parameters are not varied by
              MPFIT, but are passed on to MYFUNCT for evaluation.
  
     .LIMITED - a two-element boolean array.  If the first/second
                element is set, then the parameter is bounded on the
                lower/upper side.  A parameter can be bounded on both
                sides.  Both LIMITED and LIMITS must be given
                together.
  
     .LIMITS - a two-element float or double array.  Gives the
               parameter limits on the lower and upper sides,
               respectively.  Zero, one or two of these values can be
               set, depending on the values of LIMITED.  Both LIMITED
               and LIMITS must be given together.
  
     .PARNAME - a string, giving the name of the parameter.  The
                fitting code of MPFIT does not use this tag in any
                way.  However, the default ITERPROC will print the
                parameter name if available.
  
     .STEP - the step size to be used in calculating the numerical
             derivatives.  If set to zero, then the step size is
             computed automatically.  Ignored when AUTODERIVATIVE=0.
             This value is superceded by the RELSTEP value.

     .RELSTEP - the *relative* step size to be used in calculating
                the numerical derivatives.  This number is the
                fractional size of the step, compared to the
                parameter value.  This value supercedes the STEP
                setting.  If the parameter is zero, then a default
                step size is chosen.

     .MPSIDE - the sidedness of the finite difference when computing
               numerical derivatives.  This field can take four
               values:

                  0 - one-sided derivative computed automatically
                  1 - one-sided derivative (f(x+h) - f(x)  )/h
                 -1 - one-sided derivative (f(x)   - f(x-h))/h
                  2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)

              Where H is the STEP parameter described above.  The
              "automatic" one-sided derivative method will chose a
              direction for the finite difference which does not
              violate any constraints.  The other methods do not
              perform this check.  The two-sided method is in
              principle more precise, but requires twice as many
              function evaluations.  Default: 0.

     .MPMAXSTEP - the maximum change to be made in the parameter
                  value.  During the fitting process, the parameter
                  will never be changed by more than this value in
                  one iteration.

                  A value of 0 indicates no maximum.  Default: 0.
  
     .TIED - a string expression which "ties" the parameter to other
             free or fixed parameters.  Any expression involving
             constants and the parameter array P are permitted.
             Example: if parameter 2 is always to be twice parameter
             1 then use the following: parinfo(2).tied = '2 * P(1)'.
             Since they are totally constrained, tied parameters are
             considered to be fixed; no errors are computed for them.
             [ NOTE: the PARNAME can't be used in expressions. ]

     .MPPRINT - if set to 1, then the default ITERPROC will print the
                parameter value.  If set to 0, the parameter value
                will not be printed.  This tag can be used to
                selectively print only a few parameter values out of
                many.  Default: 1 (all parameters printed)

  
  Future modifications to the PARINFO structure, if any, will involve
  adding structure tags beginning with the two letters "MP".
  Therefore programmers are urged to avoid using tags starting with
  the same letters; otherwise they are free to include their own
  fields within the PARINFO structure, and they will be ignored.
  
  PARINFO Example:
  parinfo = replicate({value:0.D, fixed:0, limited:[0,0], $
                       limits:[0.D,0]}, 5)
  parinfo(0).fixed = 1
  parinfo(4).limited(0) = 1
  parinfo(4).limits(0)  = 50.D
  parinfo(*).value = [5.7D, 2.2, 500., 1.5, 2000.]
  
  A total of 5 parameters, with starting values of 5.7,
  2.2, 500, 1.5, and 2000 are given.  The first parameter
  is fixed at a value of 5.7, and the last parameter is
  constrained to be above 50.


 HARD-TO-COMPUTE FUNCTIONS: "EXTERNAL" EVALUATION

  The normal mode of operation for MPFIT is for the user to pass a
  function name, and MPFIT will call the user function multiple times
  as it iterates toward a solution.

  Some user functions are particularly hard to compute using the
  standard model of MPFIT.  Usually these are functions that depend
  on a large amount of external data, and so it is not feasible, or
  at least highly impractical, to have MPFIT call it.  In those cases
  it may be possible to use the "(EXTERNAL)" evaluation option.

  In this case the user is responsible for making all function *and
  derivative* evaluations.  The function and Jacobian data are passed
  in through the EXTERNAL_FVEC and EXTERNAL_FJAC keywords,
  respectively.  The user indicates the selection of this option by
  specifying a function name (MYFUNCT) of "(EXTERNAL)".  No
  user-function calls are made when EXTERNAL evaluation is being
  used.

  At the end of each iteration, control returns to the user, who must
  reevaluate the function at its new parameter values.  Users should
  check the return value of the STATUS keyword, where a value of 9
  indicates the user should supply more data for the next iteration,
  and re-call MPFIT.  The user may refrain from calling MPFIT
  further; as usual, STATUS will indicate when the solution has
  converged and no more iterations are required.

  Because MPFIT must maintain its own data structures between calls,
  the user must also pass a named variable to the EXTERNAL_STATE
  keyword.  This variable must be maintained by the user, but not
  changed, throughout the fitting process.  When no more iterations
  are desired, the named variable may be discarded.


 INPUTS:
   MYFUNCT - a string variable containing the name of the function to
             be minimized.  The function should return the weighted
             deviations between the model and the data, as described
             above.

             For EXTERNAL evaluation of functions, this parameter
             should be set to a value of "(EXTERNAL)".

   START_PARAMS - An array of starting values for each of the
                  parameters of the model.  The number of parameters
                  should be fewer than the number of measurements.
                  Also, the parameters should have the same data type
                  as the measurements (double is preferred).

                  This parameter is optional if the PARINFO keyword
                  is used (but see PARINFO).  The PARINFO keyword
                  provides a mechanism to fix or constrain individual
                  parameters.  If both START_PARAMS and PARINFO are
                  passed, then the starting *value* is taken from
                  START_PARAMS, but the *constraints* are taken from
                  PARINFO.
 
 RETURNS:

   Returns the array of best-fit parameters.


 KEYWORD PARAMETERS:

   AUTODERIVATIVE - If this is set, derivatives of the function will
                    be computed automatically via a finite
                    differencing procedure.  If not set, then MYFUNCT
                    must provide the (analytical) derivatives.
                    Default: set (=1) 
                    NOTE: to supply your own analytical derivatives,
                      explicitly pass AUTODERIVATIVE=0

   BESTNORM - the value of the summed squared residuals for the
              returned parameter values.

   COVAR - the covariance matrix for the set of parameters returned
           by MPFIT.  The matrix is NxN where N is the number of
           parameters.  The square root of the diagonal elements
           gives the formal 1-sigma statistical errors on the
           parameters IF errors were treated "properly" in MYFUNC.
           Parameter errors are also returned in PERROR.

           To compute the correlation matrix, PCOR, use this example:
           IDL> PCOR = COV * 0
           IDL> FOR i = 0, n-1 DO FOR j = 0, n-1 DO $
                PCOR(i,j) = COV(i,j)/sqrt(COV(i,i)*COV(j,j))

           If NOCOVAR is set or MPFIT terminated abnormally, then
           COVAR is set to a scalar with value !VALUES.D_NAN.

   DOF - number of degrees of freedom, computed as
             DOF = N_ELEMENTS(DEVIATES) - NFREE
         Note that this doesn't account for pegged parameters (see
         NPEGGED).

   ERRMSG - a string error or warning message is returned.

   EXTERNAL_FVEC - upon input, the function values, evaluated at
                   START_PARAMS.  This should be an M-vector, where M
                   is the number of data points.

   EXTERNAL_FJAC - upon input, the Jacobian array of partial
                   derivative values.  This should be a M x N array,
                   where M is the number of data points and N is the
                   number of parameters.  NOTE: that all FIXED or
                   TIED parameters must *not* be included in this
                   array.

   EXTERNAL_STATE - a named variable to store MPFIT-related state
                    information between iterations (used in input and
                    output to MPFIT).  The user must not manipulate
                    or discard this data until the final iteration is
                    performed.

   FASTNORM - set this keyword to select a faster algorithm to
              compute sum-of-square values internally.  For systems
              with large numbers of data points, the standard
              algorithm can become prohibitively slow because it
              cannot be vectorized well.  By setting this keyword,
              MPFIT will run faster, but it will be more prone to
              floating point overflows and underflows.  Thus, setting
              this keyword may sacrifice some stability in the
              fitting process.
              
   FTOL - a nonnegative input variable. Termination occurs when both
          the actual and predicted relative reductions in the sum of
          squares are at most FTOL (and STATUS is accordingly set to
          1 or 3).  Therefore, FTOL measures the relative error
          desired in the sum of squares.  Default: 1D-10

   FUNCTARGS - A structure which contains the parameters to be passed
               to the user-supplied function specified by MYFUNCT via
               the _EXTRA mechanism.  This is the way you can pass
               additional data to your user-supplied function without
               using common blocks.

               Consider the following example:
                if FUNCTARGS = { XVAL:[1.D,2,3], YVAL:[1.D,4,9],
                                 ERRVAL:[1.D,1,1] }
                then the user supplied function should be declared
                like this:
                FUNCTION MYFUNCT, P, XVAL=x, YVAL=y, ERRVAL=err

               By default, no extra parameters are passed to the
               user-supplied function, but your function should
               accept *at least* one keyword parameter.  [ This is to
               accomodate a limitation in IDL's _EXTRA
               parameter-passing mechanism. ]

   GTOL - a nonnegative input variable. Termination occurs when the
          cosine of the angle between fvec and any column of the
          jacobian is at most GTOL in absolute value (and STATUS is
          accordingly set to 4). Therefore, GTOL measures the
          orthogonality desired between the function vector and the
          columns of the jacobian.  Default: 1D-10

   ITERARGS - The keyword arguments to be passed to ITERPROC via the
              _EXTRA mechanism.  This should be a structure, and is
              similar in operation to FUNCTARGS.
              Default: no arguments are passed.

   ITERPROC - The name of a procedure to be called upon each NPRINT
              iteration of the MPFIT routine.  ITERPROC is always
              called in the final iteration.  It should be declared
              in the following way:

              PRO ITERPROC, MYFUNCT, p, iter, fnorm, FUNCTARGS=fcnargs, $
                PARINFO=parinfo, QUIET=quiet, DOF=dof, ...
                ; perform custom iteration update
              END
         
              ITERPROC must either accept all three keyword
              parameters (FUNCTARGS, PARINFO and QUIET), or at least
              accept them via the _EXTRA keyword.
          
              MYFUNCT is the user-supplied function to be minimized,
              P is the current set of model parameters, ITER is the
              iteration number, and FUNCTARGS are the arguments to be
              passed to MYFUNCT.  FNORM should be the chi-squared
              value.  QUIET is set when no textual output should be
              printed.  DOF is the number of degrees of freedom,
              normally the number of points less the number of free
              parameters.  See below for documentation of PARINFO.

              In implementation, ITERPROC can perform updates to the
              terminal or graphical user interface, to provide
              feedback while the fit proceeds.  If the fit is to be
              stopped for any reason, then ITERPROC should set the
              common block variable ERROR_CODE to negative value
              between -15 and -1 (see MPFIT_ERROR common block
              below).  In principle, ITERPROC should probably not
              modify the parameter values, because it may interfere
              with the algorithm's stability.  In practice it is
              allowed.

              Default: an internal routine is used to print the
                       parameter values.

   ITERSTOP - Set this keyword if you wish to be able to stop the
              fitting by hitting the predefined ITERKEYSTOP key on
              the keyboard.  This only works if you use the default
              ITERPROC.

   ITERKEYSTOP - A keyboard key which will halt the fit (and if
                 ITERSTOP is set and the default ITERPROC is used).
                 ITERSTOPKEY may either be a one-character string
                 with the desired key, or a scalar integer giving the
                 ASCII code of the desired key.  
                 Default: 7b (control-g)

                 NOTE: the default value of ASCI 7 (control-G) cannot
                 be read in some windowing environments, so you must
                 change to a printable character like 'q'.

   MAXITER - The maximum number of iterations to perform.  If the
             number is exceeded, then the STATUS value is set to 5
             and MPFIT returns.
             Default: 200 iterations

   NFEV - the number of MYFUNCT function evaluations performed.

   NFREE - the number of free parameters in the fit.  This includes
           parameters which are not FIXED and not TIED, but it does
           include parameters which are pegged at LIMITS.

   NITER - the number of iterations completed.

   NOCOVAR - set this keyword to prevent the calculation of the
             covariance matrix before returning (see COVAR)

   NPEGGED - the number of free parameters which are pegged at a
             LIMIT.

   NPRINT - The frequency with which ITERPROC is called.  A value of
            1 indicates that ITERPROC is called with every iteration,
            while 2 indicates every other iteration, etc.  Be aware
            that several Levenberg-Marquardt attempts can be made in
            a single iteration.  Also, the ITERPROC is *always*
            called for the final iteration, regardless of the
            iteration number.
            Default value: 1

   PARINFO - Provides a mechanism for more sophisticated constraints
             to be placed on parameter values.  When PARINFO is not
             passed, then it is assumed that all parameters are free
             and unconstrained.  Values in PARINFO are never 
             modified during a call to MPFIT.

             See description above for the structure of PARINFO.

             Default value:  all parameters are free and unconstrained.

   PERROR - The formal 1-sigma errors in each parameter, computed
            from the covariance matrix.  If a parameter is held
            fixed, or if it touches a boundary, then the error is
            reported as zero.

            If the fit is unweighted (i.e. no errors were given, or
            the weights were uniformly set to unity), then PERROR
            will probably not represent the true parameter
            uncertainties.  

            *If* you can assume that the true reduced chi-squared
            value is unity -- meaning that the fit is implicitly
            assumed to be of good quality -- then the estimated
            parameter uncertainties can be computed by scaling PERROR
            by the measured chi-squared value.

              DOF     = N_ELEMENTS(X) - N_ELEMENTS(PARMS) ; deg of freedom
              PCERROR = PERROR * SQRT(BESTNORM / DOF)   ; scaled uncertainties

   QUIET - set this keyword when no textual output should be printed
           by MPFIT

   RESDAMP - a scalar number, indicating the cut-off value of
             residuals where "damping" will occur.  Residuals with
             magnitudes greater than this number will be replaced by
             their logarithm.  This partially mitigates the so-called
             large residual problem inherent in least-squares solvers
             (as for the test problem CURVI, http://www.maxthis.com/-
             curviex.htm).  A value of 0 indicates no damping.
             Default: 0

             Note: RESDAMP doesn't work with AUTODERIV=0

   STATUS - an integer status code is returned.  All values greater
            than zero can represent success (however STATUS EQ 5 may
            indicate failure to converge).  It can have one of the
            following values:

        -16  a parameter or function value has become infinite or an
             undefined number.  This is usually a consequence of
             numerical overflow in the user's model function, which
             must be avoided.

        -15 to -1 
             these are error codes that either MYFUNCT or ITERPROC
             may return to terminate the fitting process (see
             description of MPFIT_ERROR common below).  If either
             MYFUNCT or ITERPROC set ERROR_CODE to a negative number,
             then that number is returned in STATUS.  Values from -15
             to -1 are reserved for the user functions and will not
             clash with MPFIT.

	   0  improper input parameters.
         
	   1  both actual and predicted relative reductions
	      in the sum of squares are at most FTOL.
         
	   2  relative error between two consecutive iterates
	      is at most XTOL
         
	   3  conditions for STATUS = 1 and STATUS = 2 both hold.
         
	   4  the cosine of the angle between fvec and any
	      column of the jacobian is at most GTOL in
	      absolute value.
         
	   5  the maximum number of iterations has been reached
         
	   6  FTOL is too small. no further reduction in
	      the sum of squares is possible.
         
	   7  XTOL is too small. no further improvement in
	      the approximate solution x is possible.
         
	   8  GTOL is too small. fvec is orthogonal to the
	      columns of the jacobian to machine precision.

          9  A successful single iteration has been completed, and
             the user must supply another "EXTERNAL" evaluation of
             the function and its derivatives.  This status indicator
             is neither an error nor a convergence indicator.

   XTOL - a nonnegative input variable. Termination occurs when the
          relative error between two consecutive iterates is at most
          XTOL (and STATUS is accordingly set to 2 or 3).  Therefore,
          XTOL measures the relative error desired in the approximate
          solution.  Default: 1D-10


 EXAMPLE:

   p0 = [5.7D, 2.2, 500., 1.5, 2000.]
   fa = {X:x, Y:y, ERR:err}
   p = mpfit('MYFUNCT', p0, functargs=fa)

   Minimizes sum of squares of MYFUNCT.  MYFUNCT is called with the X,
   Y, and ERR keyword parameters that are given by FUNCTARGS.  The
   resulting parameter values are returned in p.


 COMMON BLOCKS:

   COMMON MPFIT_ERROR, ERROR_CODE

     User routines may stop the fitting process at any time by
     setting an error condition.  This condition may be set in either
     the user's model computation routine (MYFUNCT), or in the
     iteration procedure (ITERPROC).

     To stop the fitting, the above common block must be declared,
     and ERROR_CODE must be set to a negative number.  After the user
     procedure or function returns, MPFIT checks the value of this
     common block variable and exits immediately if the error
     condition has been set.  This value is also returned in the
     STATUS keyword: values of -1 through -15 are reserved error
     codes for the user routines.  By default the value of ERROR_CODE
     is zero, indicating a successful function/procedure call.

   COMMON MPFIT_PROFILE
   COMMON MPFIT_MACHAR
   COMMON MPFIT_CONFIG

     These are undocumented common blocks are used internally by
     MPFIT and may change in future implementations.

 THEORY OF OPERATION:

   There are many specific strategies for function minimization.  One
   very popular technique is to use function gradient information to
   realize the local structure of the function.  Near a local minimum
   the function value can be taylor expanded about x0 as follows:

      f(x) = f(x0) + f'(x0) . (x-x0) + (1/2) (x-x0) . f''(x0) . (x-x0)
             -----   ---------------   -------------------------------  (1)
     Order    0th          1st                      2nd

   Here f'(x) is the gradient vector of f at x, and f''(x) is the
   Hessian matrix of second derivatives of f at x.  The vector x is
   the set of function parameters, not the measured data vector.  One
   can find the minimum of f, f(xm) using Newton's method, and
   arrives at the following linear equation:

      f''(x0) . (xm-x0) = - f'(x0)                            (2)

   If an inverse can be found for f''(x0) then one can solve for
   (xm-x0), the step vector from the current position x0 to the new
   projected minimum.  Here the problem has been linearized (ie, the
   gradient information is known to first order).  f''(x0) is
   symmetric n x n matrix, and should be positive definite.

   The Levenberg - Marquardt technique is a variation on this theme.
   It adds an additional diagonal term to the equation which may aid the
   convergence properties:

      (f''(x0) + nu I) . (xm-x0) = -f'(x0)                  (2a)

   where I is the identity matrix.  When nu is large, the overall
   matrix is diagonally dominant, and the iterations follow steepest
   descent.  When nu is small, the iterations are quadratically
   convergent.

   In principle, if f''(x0) and f'(x0) are known then xm-x0 can be
   determined.  However the Hessian matrix is often difficult or
   impossible to compute.  The gradient f'(x0) may be easier to
   compute, if even by finite difference techniques.  So-called
   quasi-Newton techniques attempt to successively estimate f''(x0)
   by building up gradient information as the iterations proceed.

   In the least squares problem there are further simplifications
   which assist in solving eqn (2).  The function to be minimized is
   a sum of squares:

       f = Sum(hi^2)                                         (3)

   where hi is the ith residual out of m residuals as described
   above.  This can be substituted back into eqn (2) after computing
   the derivatives:

       f'  = 2 Sum(hi  hi')     
       f'' = 2 Sum(hi' hj') + 2 Sum(hi hi'')                (4)

   If one assumes that the parameters are already close enough to a
   minimum, then one typically finds that the second term in f'' is
   negligible [or, in any case, is too difficult to compute].  Thus,
   equation (2) can be solved, at least approximately, using only
   gradient information.

   In matrix notation, the combination of eqns (2) and (4) becomes:

        hT' . h' . dx = - hT' . h                          (5)

   Where h is the residual vector (length m), hT is its transpose, h'
   is the Jacobian matrix (dimensions n x m), and dx is (xm-x0).  The
   user function supplies the residual vector h, and in some cases h'
   when it is not found by finite differences (see MPFIT_FDJAC2,
   which finds h and hT').  Even if dx is not the best absolute step
   to take, it does provide a good estimate of the best *direction*,
   so often a line minimization will occur along the dx vector
   direction.

   The method of solution employed by MINPACK is to form the Q . R
   factorization of h', where Q is an orthogonal matrix such that QT .
   Q = I, and R is upper right triangular.  Using h' = Q . R and the
   ortogonality of Q, eqn (5) becomes

        (RT . QT) . (Q . R) . dx = - (RT . QT) . h
                     RT . R . dx = - RT . QT . h         (6)
                          R . dx = - QT . h

   where the last statement follows because R is upper triangular.
   Here, R, QT and h are known so this is a matter of solving for dx.
   The routine MPFIT_QRFAC provides the QR factorization of h, with
   pivoting, and MPFIT_QRSOLV provides the solution for dx.
   
 REFERENCES:

   MINPACK-1, Jorge More', available from netlib (www.netlib.org).
   "Optimization Software Guide," Jorge More' and Stephen Wright, 
     SIAM, *Frontiers in Applied Mathematics*, Number 14.
   More', Jorge J., "The Levenberg-Marquardt Algorithm:
     Implementation and Theory," in *Numerical Analysis*, ed. Watson,
     G. A., Lecture Notes in Mathematics 630, Springer-Verlag, 1977.

 MODIFICATION HISTORY:
   Translated from MINPACK-1 in FORTRAN, Apr-Jul 1998, CM
   Fixed bug in parameter limits (x vs xnew), 04 Aug 1998, CM
   Added PERROR keyword, 04 Aug 1998, CM
   Added COVAR keyword, 20 Aug 1998, CM
   Added NITER output keyword, 05 Oct 1998
      D.L Windt, Bell Labs, windt@bell-labs.com;
   Made each PARINFO component optional, 05 Oct 1998 CM
   Analytical derivatives allowed via AUTODERIVATIVE keyword, 09 Nov 1998
   Parameter values can be tied to others, 09 Nov 1998
   Fixed small bugs (Wayne Landsman), 24 Nov 1998
   Added better exception error reporting, 24 Nov 1998 CM
   Cosmetic documentation changes, 02 Jan 1999 CM
   Changed definition of ITERPROC to be consistent with TNMIN, 19 Jan 1999 CM
   Fixed bug when AUTDERIVATIVE=0.  Incorrect sign, 02 Feb 1999 CM
   Added keyboard stop to MPFIT_DEFITER, 28 Feb 1999 CM
   Cosmetic documentation changes, 14 May 1999 CM
   IDL optimizations for speed & FASTNORM keyword, 15 May 1999 CM
   Tried a faster version of mpfit_enorm, 30 May 1999 CM
   Changed web address to cow.physics.wisc.edu, 14 Jun 1999 CM
   Found malformation of FDJAC in MPFIT for 1 parm, 03 Aug 1999 CM
   Factored out user-function call into MPFIT_CALL.  It is possible,
     but currently disabled, to call procedures.  The calling format
     is similar to CURVEFIT, 25 Sep 1999, CM
   Slightly changed mpfit_tie to be less intrusive, 25 Sep 1999, CM
   Fixed some bugs associated with tied parameters in mpfit_fdjac, 25
     Sep 1999, CM
   Reordered documentation; now alphabetical, 02 Oct 1999, CM
   Added QUERY keyword for more robust error detection in drivers, 29
     Oct 1999, CM
   Documented PERROR for unweighted fits, 03 Nov 1999, CM
   Split out MPFIT_RESETPROF to aid in profiling, 03 Nov 1999, CM
   Some profiling and speed optimization, 03 Nov 1999, CM
     Worst offenders, in order: fdjac2, qrfac, qrsolv, enorm.
     fdjac2 depends on user function, qrfac and enorm seem to be
     fully optimized.  qrsolv probably could be tweaked a little, but
     is still <10% of total compute time.
   Made sure that !err was set to 0 in MPFIT_DEFITER, 10 Jan 2000, CM
   Fixed small inconsistency in setting of QANYLIM, 28 Jan 2000, CM
   Added PARINFO field RELSTEP, 28 Jan 2000, CM
   Converted to MPFIT_ERROR common block for indicating error
     conditions, 28 Jan 2000, CM
   Corrected scope of MPFIT_ERROR common block, CM, 07 Mar 2000
   Minor speed improvement in MPFIT_ENORM, CM 26 Mar 2000
   Corrected case where ITERPROC changed parameter values and
     parameter values were TIED, CM 26 Mar 2000
   Changed MPFIT_CALL to modify NFEV automatically, and to support
     user procedures more, CM 26 Mar 2000
   Copying permission terms have been liberalized, 26 Mar 2000, CM
   Catch zero value of zero a(j,lj) in MPFIT_QRFAC, 20 Jul 2000, CM
      (thanks to David Schlegel <schlegel@astro.princeton.edu>)
   MPFIT_SETMACHAR is called only once at init; only one common block
     is created (MPFIT_MACHAR); it is now a structure; removed almost
     all CHECK_MATH calls for compatibility with IDL5 and !EXCEPT;
     profiling data is now in a structure too; noted some
     mathematical discrepancies in Linux IDL5.0, 17 Nov 2000, CM
   Some significant changes.  New PARINFO fields: MPSIDE, MPMINSTEP,
     MPMAXSTEP.  Improved documentation.  Now PTIED constraints are
     maintained in the MPCONFIG common block.  A new procedure to
     parse PARINFO fields.  FDJAC2 now computes a larger variety of
     one-sided and two-sided finite difference derivatives.  NFEV is
     stored in the MPCONFIG common now.  17 Dec 2000, CM
   Added check that PARINFO and XALL have same size, 29 Dec 2000 CM
   Don't call function in TERMINATE when there is an error, 05 Jan
     2000
   Check for float vs. double discrepancies; corrected implementation
     of MIN/MAXSTEP, which I still am not sure of, but now at least
     the correct behavior occurs *without* it, CM 08 Jan 2001
   Added SCALE_FCN keyword, to allow for scaling, as for the CASH
     statistic; added documentation about the theory of operation,
     and under the QR factorization; slowly I'm beginning to
     understand the bowels of this algorithm, CM 10 Jan 2001
   Remove MPMINSTEP field of PARINFO, for now at least, CM 11 Jan
     2001
   Added RESDAMP keyword, CM, 14 Jan 2001
   Tried to improve the DAMP handling a little, CM, 13 Mar 2001
   Corrected .PARNAME behavior in _DEFITER, CM, 19 Mar 2001
   Added checks for parameter and function overflow; a new STATUS
     value to reflect this; STATUS values of -15 to -1 are reserved
     for user function errors, CM, 03 Apr 2001
   DAMP keyword is now a TANH, CM, 03 Apr 2001
   Added more error checking of float vs. double, CM, 07 Apr 2001
   Fixed bug in handling of parameter lower limits; moved overflow
     checking to end of loop, CM, 20 Apr 2001
   Failure using GOTO, TERMINATE more graceful if FNORM1 not defined,
     CM, 13 Aug 2001
   Add MPPRINT tag to PARINFO, CM, 19 Nov 2001
   Add DOF keyword to DEFITER procedure, and print degrees of
     freedom, CM, 28 Nov 2001
   Add check to be sure MYFUNCT is a scalar string, CM, 14 Jan 2002
   Addition of EXTERNAL_FJAC, EXTERNAL_FVEC keywords; ability to save
     fitter's state from one call to the next; allow '(EXTERNAL)'
     function name, which implies that user will supply function and
     Jacobian at each iteration, CM, 10 Mar 2002
   Documented EXTERNAL evaluation code, CM, 10 Mar 2002
   Corrected signficant bug in the way that the STEP parameter, and
     FIXED parameters interacted (Thanks Andrew Steffl), CM, 02 Apr
     2002
   Allow COVAR and PERROR keywords to be computed, even in case of
     '(EXTERNAL)' function, 26 May 2002
   Add NFREE and NPEGGED keywords; compute NPEGGED; compute DOF using
     NFREE instead of n_elements(X), thanks to Kristian Kjaer, CM 11
     Sep 2002
   Hopefully PERROR is all positive now, CM 13 Sep 2002
   Documented RELSTEP field of PARINFO (!!), CM, 25 Oct 2002
   Error checking to detect missing start pars, CM 12 Apr 2003
   Add DOF keyword to return degrees of freedom, CM, 30 June 2003
   Always call ITERPROC in the final iteration; add ITERKEYSTOP
     keyword, CM, 30 June 2003
   Correct bug in MPFIT_LMPAR of singularity handling, which might
     likely be fatal for one-parameter fits, CM, 21 Nov 2003
     (with thanks to Peter Tuthill for the proper test case)

  $Id: mpfit.pro,v 1.30 2003/11/24 01:51:13 craigm Exp $
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mpfit.pro)</STRONG><P>
<HR>
 
<A NAME="MPFITFUN">
<H2>MPFITFUN</H2></A>
<A HREF="#MPFIT">[Previous Routine]</A>
<A HREF="#N">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   MPFITFUN

 AUTHOR:
   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770
   craigm@lheamail.gsfc.nasa.gov
   UPDATED VERSIONs can be found on my WEB PAGE: 
      http://cow.physics.wisc.edu/~craigm/idl/idl.html

 PURPOSE:
   Perform Levenberg-Marquardt least-squares fit to IDL function

 MAJOR TOPICS:
   Curve and Surface Fitting

 CALLING SEQUENCE:
   parms = MPFITFUN(MYFUNCT, X, Y, ERR, start_params, ...)

 DESCRIPTION:

  MPFITFUN fits a user-supplied model -- in the form of an IDL
  function -- to a set of user-supplied data.  MPFITFUN calls
  MPFIT, the MINPACK-1 least-squares minimizer, to do the main
  work.

  Given the data and their uncertainties, MPFITFUN finds the best set
  of model parameters which match the data (in a least-squares
  sense) and returns them in an array.
  
  The user must supply the following items:
   - An array of independent variable values ("X").
   - An array of "measured" *dependent* variable values ("Y").
   - An array of "measured" 1-sigma uncertainty values ("ERR").
   - The name of an IDL function which computes Y given X ("MYFUNCT").
   - Starting guesses for all of the parameters ("START_PARAMS").

  There are very few restrictions placed on X, Y or MYFUNCT.  Simply
  put, MYFUNCT must map the "X" values into "Y" values given the
  model parameters.  The "X" values may represent any independent
  variable (not just Cartesian X), and indeed may be multidimensional
  themselves.  For example, in the application of image fitting, X
  may be a 2xN array of image positions.

  MPFITFUN carefully avoids passing large arrays where possible to
  improve performance.

  See below for an example of usage.

 USER FUNCTION

  The user must define a function which returns the model value.  For
  applications which use finite-difference derivatives -- the default
  -- the user function should be declared in the following way:

    FUNCTION MYFUNCT, X, P
     ; The independent variable is X
     ; Parameter values are passed in "P"
     YMOD = ... computed model values at X ...
     return, YMOD
    END

  The returned array YMOD must have the same dimensions and type as
  the "measured" Y values.

  User functions may also indicate a fatal error condition
  using the ERROR_CODE common block variable, as described
  below under the MPFIT_ERROR common block definition.

  See the discussion under "ANALYTIC DERIVATIVES" and AUTODERIVATIVE
  in MPFIT.PRO if you wish to compute the derivatives for yourself.
  AUTODERIVATIVE is accepted by MPFITFUN and passed directly to
  MPFIT.  The user function must accept one additional parameter, DP,
  which contains the derivative of the user function with respect to
  each parameter at each data point, as described in MPFIT.PRO.

 CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD

  The behavior of MPFIT can be modified with respect to each
  parameter to be fitted.  A parameter value can be fixed; simple
  boundary constraints can be imposed; limitations on the parameter
  changes can be imposed; properties of the automatic derivative can
  be modified; and parameters can be tied to one another.

  These properties are governed by the PARINFO structure, which is
  passed as a keyword parameter to MPFIT.

  PARINFO should be an array of structures, one for each parameter.
  Each parameter is associated with one element of the array, in
  numerical order.  The structure can have the following entries
  (none are required):
  
     .VALUE - the starting parameter value (but see the START_PARAMS
              parameter for more information).
  
     .FIXED - a boolean value, whether the parameter is to be held
              fixed or not.  Fixed parameters are not varied by
              MPFIT, but are passed on to MYFUNCT for evaluation.
  
     .LIMITED - a two-element boolean array.  If the first/second
                element is set, then the parameter is bounded on the
                lower/upper side.  A parameter can be bounded on both
                sides.  Both LIMITED and LIMITS must be given
                together.
  
     .LIMITS - a two-element float or double array.  Gives the
               parameter limits on the lower and upper sides,
               respectively.  Zero, one or two of these values can be
               set, depending on the values of LIMITED.  Both LIMITED
               and LIMITS must be given together.
  
     .PARNAME - a string, giving the name of the parameter.  The
                fitting code of MPFIT does not use this tag in any
                way.  However, the default ITERPROC will print the
                parameter name if available.
  
     .STEP - the step size to be used in calculating the numerical
             derivatives.  If set to zero, then the step size is
             computed automatically.  Ignored when AUTODERIVATIVE=0.
             This value is superceded by the RELSTEP value.

     .RELSTEP - the *relative* step size to be used in calculating
                the numerical derivatives.  This number is the
                fractional size of the step, compared to the
                parameter value.  This value supercedes the STEP
                setting.  If the parameter is zero, then a default
                step size is chosen.

     .MPSIDE - the sidedness of the finite difference when computing
               numerical derivatives.  This field can take four
               values:

                  0 - one-sided derivative computed automatically
                  1 - one-sided derivative (f(x+h) - f(x)  )/h
                 -1 - one-sided derivative (f(x)   - f(x-h))/h
                  2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)

              Where H is the STEP parameter described above.  The
              "automatic" one-sided derivative method will chose a
              direction for the finite difference which does not
              violate any constraints.  The other methods do not
              perform this check.  The two-sided method is in
              principle more precise, but requires twice as many
              function evaluations.  Default: 0.

     .MPMINSTEP - the minimum change to be made in the parameter
                  value.  During the fitting process, the parameter
                  will be changed by multiples of this value.  The
                  actual step is computed as:

                     DELTA1 = MPMINSTEP*ROUND(DELTA0/MPMINSTEP)

                  where DELTA0 and DELTA1 are the estimated parameter
                  changes before and after this constraint is
                  applied.  Note that this constraint should be used
                  with care since it may cause non-converging,
                  oscillating solutions.

                  A value of 0 indicates no minimum.  Default: 0.

     .MPMAXSTEP - the maximum change to be made in the parameter
                  value.  During the fitting process, the parameter
                  will never be changed by more than this value.

                  A value of 0 indicates no maximum.  Default: 0.
  
     .TIED - a string expression which "ties" the parameter to other
             free or fixed parameters.  Any expression involving
             constants and the parameter array P are permitted.
             Example: if parameter 2 is always to be twice parameter
             1 then use the following: parinfo(2).tied = '2 * P(1)'.
             Since they are totally constrained, tied parameters are
             considered to be fixed; no errors are computed for them.
             [ NOTE: the PARNAME can't be used in expressions. ]
  
  Future modifications to the PARINFO structure, if any, will involve
  adding structure tags beginning with the two letters "MP".
  Therefore programmers are urged to avoid using tags starting with
  the same letters; otherwise they are free to include their own
  fields within the PARINFO structure, and they will be ignored.
  
  PARINFO Example:
  parinfo = replicate({value:0.D, fixed:0, limited:[0,0], $
                       limits:[0.D,0]}, 5)
  parinfo(0).fixed = 1
  parinfo(4).limited(0) = 1
  parinfo(4).limits(0)  = 50.D
  parinfo(*).value = [5.7D, 2.2, 500., 1.5, 2000.]
  
  A total of 5 parameters, with starting values of 5.7,
  2.2, 500, 1.5, and 2000 are given.  The first parameter
  is fixed at a value of 5.7, and the last parameter is
  constrained to be above 50.

 INPUTS:
   MYFUNCT - a string variable containing the name of an IDL function.
             This function computes the "model" Y values given the
             X values and model parameters, as desribed above.

   X - Array of independent variable values.

   Y - Array of "measured" dependent variable values.  Y should have
       the same data type as X.  The function MYFUNCT should map
       X->Y.

   ERR - Array of "measured" 1-sigma uncertainties.  ERR should have
         the same data type as Y.  ERR is ignored if the WEIGHTS
         keyword is specified.

   START_PARAMS - An array of starting values for each of the
                  parameters of the model.  The number of parameters
                  should be fewer than the number of measurements.
                  Also, the parameters should have the same data type
                  as the measurements (double is preferred).

                  This parameter is optional if the PARINFO keyword
                  is used (see MPFIT).  The PARINFO keyword provides
                  a mechanism to fix or constrain individual
                  parameters.  If both START_PARAMS and PARINFO are
                  passed, then the starting *value* is taken from
                  START_PARAMS, but the *constraints* are taken from
                  PARINFO.
 

 RETURNS:

   Returns the array of best-fit parameters.


 KEYWORD PARAMETERS:

   BESTNORM - the value of the summed squared residuals for the
              returned parameter values.

   COVAR - the covariance matrix for the set of parameters returned
           by MPFIT.  The matrix is NxN where N is the number of
           parameters.  The square root of the diagonal elements
           gives the formal 1-sigma statistical errors on the
           parameters IF errors were treated "properly" in MYFUNC.
           Parameter errors are also returned in PERROR.

           To compute the correlation matrix, PCOR, use this:
           IDL> PCOR = COV * 0
           IDL> FOR i = 0, n-1 DO FOR j = 0, n-1 DO $
                PCOR(i,j) = COV(i,j)/sqrt(COV(i,i)*COV(j,j))

           If NOCOVAR is set or MPFIT terminated abnormally, then
           COVAR is set to a scalar with value !VALUES.D_NAN.

   CASH - when set, the fit statistic is changed to a derivative of
          the CASH statistic.  The model function must be strictly
          positive.

   DOF - number of degrees of freedom, computed as
             DOF = N_ELEMENTS(DEVIATES) - NFREE
         Note that this doesn't account for pegged parameters (see
         NPEGGED).

   ERRMSG - a string error or warning message is returned.

   FTOL - a nonnegative input variable. Termination occurs when both
          the actual and predicted relative reductions in the sum of
          squares are at most FTOL (and STATUS is accordingly set to
          1 or 3).  Therefore, FTOL measures the relative error
          desired in the sum of squares.  Default: 1D-10

   FUNCTARGS - A structure which contains the parameters to be passed
               to the user-supplied function specified by MYFUNCT via
               the _EXTRA mechanism.  This is the way you can pass
               additional data to your user-supplied function without
               using common blocks.

               By default, no extra parameters are passed to the
               user-supplied function.

   GTOL - a nonnegative input variable. Termination occurs when the
          cosine of the angle between fvec and any column of the
          jacobian is at most GTOL in absolute value (and STATUS is
          accordingly set to 4). Therefore, GTOL measures the
          orthogonality desired between the function vector and the
          columns of the jacobian.  Default: 1D-10

   ITERARGS - The keyword arguments to be passed to ITERPROC via the
              _EXTRA mechanism.  This should be a structure, and is
              similar in operation to FUNCTARGS.
              Default: no arguments are passed.

   ITERPROC - The name of a procedure to be called upon each NPRINT
              iteration of the MPFIT routine.  It should be declared
              in the following way:

              PRO ITERPROC, MYFUNCT, p, iter, fnorm, FUNCTARGS=fcnargs, $
                PARINFO=parinfo, QUIET=quiet, ...
                ; perform custom iteration update
              END
         
              ITERPROC must either accept all three keyword
              parameters (FUNCTARGS, PARINFO and QUIET), or at least
              accept them via the _EXTRA keyword.
          
              MYFUNCT is the user-supplied function to be minimized,
              P is the current set of model parameters, ITER is the
              iteration number, and FUNCTARGS are the arguments to be
              passed to MYFUNCT.  FNORM should be the
              chi-squared value.  QUIET is set when no textual output
              should be printed.  See below for documentation of
              PARINFO.

              In implementation, ITERPROC can perform updates to the
              terminal or graphical user interface, to provide
              feedback while the fit proceeds.  If the fit is to be
              stopped for any reason, then ITERPROC should set the
              common block variable ERROR_CODE to negative value (see
              MPFIT_ERROR common block below).  In principle,
              ITERPROC should probably not modify the parameter
              values, because it may interfere with the algorithm's
              stability.  In practice it is allowed.

              Default: an internal routine is used to print the
                       parameter values.

   MAXITER - The maximum number of iterations to perform.  If the
             number is exceeded, then the STATUS value is set to 5
             and MPFIT returns.
             Default: 200 iterations

   NFEV - the number of MYFUNCT function evaluations performed.

   NFREE - the number of free parameters in the fit.  This includes
           parameters which are not FIXED and not TIED, but it does
           include parameters which are pegged at LIMITS.

   NITER - the number of iterations completed.

   NOCOVAR - set this keyword to prevent the calculation of the
             covariance matrix before returning (see COVAR)

   NPEGGED - the number of free parameters which are pegged at a
             LIMIT.

   NPRINT - The frequency with which ITERPROC is called.  A value of
            1 indicates that ITERPROC is called with every iteration,
            while 2 indicates every other iteration, etc.  Note that
            several Levenberg-Marquardt attempts can be made in a
            single iteration.
            Default value: 1

   PARINFO - Provides a mechanism for more sophisticated constraints
             to be placed on parameter values.  When PARINFO is not
             passed, then it is assumed that all parameters are free
             and unconstrained.  Values in PARINFO are never 
             modified during a call to MPFIT.

             See description above for the structure of PARINFO.

             Default value:  all parameters are free and unconstrained.

   PERROR - The formal 1-sigma errors in each parameter, computed
            from the covariance matrix.  If a parameter is held
            fixed, or if it touches a boundary, then the error is
            reported as zero.

            If the fit is unweighted (i.e. no errors were given, or
            the weights were uniformly set to unity), then PERROR
            will probably not represent the true parameter
            uncertainties.  

            *If* you can assume that the true reduced chi-squared
            value is unity -- meaning that the fit is implicitly
            assumed to be of good quality -- then the estimated
            parameter uncertainties can be computed by scaling PERROR
            by the measured chi-squared value.

              DOF     = N_ELEMENTS(X) - N_ELEMENTS(PARMS) ; deg of freedom
              PCERROR = PERROR * SQRT(BESTNORM / DOF)   ; scaled uncertainties

   QUIET - set this keyword when no textual output should be printed
           by MPFIT

   STATUS - an integer status code is returned.  All values other
            than zero can represent success.  It can have one of the
            following values:

	   0  improper input parameters.
         
	   1  both actual and predicted relative reductions
	      in the sum of squares are at most FTOL.
         
	   2  relative error between two consecutive iterates
	      is at most XTOL
         
	   3  conditions for STATUS = 1 and STATUS = 2 both hold.
         
	   4  the cosine of the angle between fvec and any
	      column of the jacobian is at most GTOL in
	      absolute value.
         
	   5  the maximum number of iterations has been reached
         
	   6  FTOL is too small. no further reduction in
	      the sum of squares is possible.
         
	   7  XTOL is too small. no further improvement in
	      the approximate solution x is possible.
         
	   8  GTOL is too small. fvec is orthogonal to the
	      columns of the jacobian to machine precision.

   WEIGHTS - Array of weights to be used in calculating the
             chi-squared value.  If WEIGHTS is specified then the ERR
             parameter is ignored.  The chi-squared value is computed
             as follows:

                CHISQ = TOTAL( (Y-MYFUNCT(X,P))^2 * ABS(WEIGHTS) )

             Here are common values of WEIGHTS:

                1D/ERR^2 - Normal weighting (ERR is the measurement error)
                1D/Y     - Poisson weighting (counting statistics)
                1D       - Unweighted

   XTOL - a nonnegative input variable. Termination occurs when the
          relative error between two consecutive iterates is at most
          XTOL (and STATUS is accordingly set to 2 or 3).  Therefore,
          XTOL measures the relative error desired in the approximate
          solution.  Default: 1D-10

   YFIT - the best-fit model function, as returned by MYFUNCT.

   
 EXAMPLE:

   ; First, generate some synthetic data
   npts = 200
   x  = dindgen(npts) * 0.1 - 10.                  ; Independent variable 
   yi = gauss1(x, [2.2D, 1.4, 3000.])              ; "Ideal" Y variable
   y  = yi + randomn(seed, npts) * sqrt(1000. + yi); Measured, w/ noise
   sy = sqrt(1000.D + y)                           ; Poisson errors

   ; Now fit a Gaussian to see how well we can recover
   p0 = [1.D, 1., 1000.]                   ; Initial guess (cent, width, area)
   p = mpfitfun('GAUSS1', x, y, sy, p0)    ; Fit a function
   print, p

   Generates a synthetic data set with a Gaussian peak, and Poisson
   statistical uncertainty.  Then the same function is fitted to the
   data (with different starting parameters) to see how close we can
   get.


 COMMON BLOCKS:

   COMMON MPFIT_ERROR, ERROR_CODE

     User routines may stop the fitting process at any time by
     setting an error condition.  This condition may be set in either
     the user's model computation routine (MYFUNCT), or in the
     iteration procedure (ITERPROC).

     To stop the fitting, the above common block must be declared,
     and ERROR_CODE must be set to a negative number.  After the user
     procedure or function returns, MPFIT checks the value of this
     common block variable and exits immediately if the error
     condition has been set.  By default the value of ERROR_CODE is
     zero, indicating a successful function/procedure call.

 REFERENCES:

   MINPACK-1, Jorge More', available from netlib (www.netlib.org).
   "Optimization Software Guide," Jorge More' and Stephen Wright, 
     SIAM, *Frontiers in Applied Mathematics*, Number 14.

 MODIFICATION HISTORY:
   Written, Apr-Jul 1998, CM
   Added PERROR keyword, 04 Aug 1998, CM
   Added COVAR keyword, 20 Aug 1998, CM
   Added ITER output keyword, 05 Oct 1998
      D.L Windt, Bell Labs, windt@bell-labs.com;
   Added ability to return model function in YFIT, 09 Nov 1998
   Analytical derivatives allowed via AUTODERIVATIVE keyword, 09 Nov 1998
   Parameter values can be tied to others, 09 Nov 1998
   Cosmetic documentation updates, 16 Apr 1999, CM
   More cosmetic documentation updates, 14 May 1999, CM
   Made sure to update STATUS, 25 Sep 1999, CM
   Added WEIGHTS keyword, 25 Sep 1999, CM
   Changed from handles to common blocks, 25 Sep 1999, CM
     - commons seem much cleaner and more logical in this case.
   Alphabetized documented keywords, 02 Oct 1999, CM
   Added QUERY keyword and query checking of MPFIT, 29 Oct 1999, CM
   Corrected EXAMPLE (offset of 1000), 30 Oct 1999, CM
   Check to be sure that X and Y are present, 02 Nov 1999, CM
   Documented PERROR for unweighted fits, 03 Nov 1999, CM
   Changed to ERROR_CODE for error condition, 28 Jan 2000, CM
   Corrected errors in EXAMPLE, 26 Mar 2000, CM
   Copying permission terms have been liberalized, 26 Mar 2000, CM
   Propagated improvements from MPFIT, 17 Dec 2000, CM
   Added CASH statistic, 10 Jan 2001
   Added NFREE and NPEGGED keywords, 11 Sep 2002, CM
   Documented RELSTEP field of PARINFO (!!), CM, 25 Oct 2002
   Add DOF keyword to return degrees of freedom, CM, 23 June 2003

  $Id: mpfitfun.pro,v 1.6 2003/06/30 21:47:36 craigm Exp $
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mpfitfun.pro)</STRONG><P>
<HR>
 
<A NAME="N">
<H2>N</H2></A>
<A HREF="#MPFITFUN">[Previous Routine]</A>
<A HREF="#N2G">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	N

PURPOSE:
	This function is simply a space saver for FOR loops

OUTPUT:
	n_elements(x)-1
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="N2G">
<H2>N2G</H2></A>
<A HREF="#N">[Previous Routine]</A>
<A HREF="#NUM2STR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	N2G
	
PURPOSE:
	This is a handy little function for easily inserting greek letters into plots without having
	to memorize formatting codes that are device dependent.

CALLING SEQUENCE
	result=N2G(str)
	
INPUTS:
	str:		STR of greek letter name (ie 'alpha', 'beta')
			Capitalize the first letter for capital greek letters

OPTIONAL INPUTS:
	font:	INT of the font number being used that's not DEFAULT = 3

OUPUTS:
	result: 	STR of the format code to put the greek letter in a string that
			will be sent to the postscript or x-windows device	

EXAMPLE:
	The proper way to insert a greek letter in a plot title would be:
		title='!7t!3 vs. Radiated Power' 
	where !7 selects the symbol font, tau=t and !3 returns to Helvetica.
	The problem comes in when !9 is needed when using the PS device and the mapping of roman letter
	to greek letter changes.  So N2G keeps track of all this and let's the user just say what they mean.
		title=n2g('tau')+' vs. Radiated Power'
	The formatting will change if the PS device is active and include the font changing commands.

MODIFICATION HISTORY:
	Written by: 	ML Reinke  - 4/16/07

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="NUM2STR">
<H2>NUM2STR</H2></A>
<A HREF="#N2G">[Previous Routine]</A>
<A HREF="#OPENWIN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	NUM2STR

PURPOSE:
	This function converts an input FLT,INT,LONINT to a string.  Really this program sucks, but I want to fucking
	strangle RSI for not having a native fully functional num2str() function.  They're bastard coated
	bastards with bastard filling.  Really, I mean whats their fuckin' problem.  You think I'm over reacting,
	but just try and put string(n) into something and notice how fucked up it is.

CALLING SEQUENCE:
	result=NUM2STR(n)

OPTIONAL INPUTS
	raw:	Use num2str(n,raw) to convert 'n' directly w/o leading zeros (use for shot numbers)
	dp:	dp = INT to set the number of decimal points 

KEYWORD PARMAMETERS:
	verb:	/verb to print status messages (used for debugging)
	sn:	/sn forces scientific notation for numbers below IDL's limit (1.0e6)

RESTRICTIONS
	Can only have 8 total digits in a FLT

MODIFICATION HISTORY
	Written by: 	ML Reinke
	8-04-05		ML Reinke - finally fixed trailing zeros issue and added a dp flag to choose the # decimal points
	6-13-06		ML Reinke - added the ability to handle floats above 1.0e6 and force scientific notation
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="OPENWIN">
<H2>OPENWIN</H2></A>
<A HREF="#NUM2STR">[Previous Routine]</A>
<A HREF="#REMOUT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	OPENWIN

PURPOSE:
	This procedure opens new x-windows or sets them to active if they are open and the
	right size.  If the PS device is active then nothing happens.  This procedure should
	be used for all window management since it is device independent (for X and PS)

CALLING SEQUENCE:
	openwin,n

INPUTS:
	n:	INT	window nubmer (0-31)

OPTIONAL INPUTS:
	xsize,ysize,xpos,ypos,title are carred through to the window command


MODIFICATION HISTORY:
	Written by:	ML Reinke - 2007
	1-24-08:	ML Reinke - added the ability to force a new window with xsize and ysize

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="REMOUT">
<H2>REMOUT</H2></A>
<A HREF="#OPENWIN">[Previous Routine]</A>
<A HREF="#RUNS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	REMOUT

PURPOSE:
	The purpose of this function is to remove outliers from a dataset by repeatedly
	truncating a dataset until all it's points lie within a user-definable number of
	standard deviations.

CALLING SEQUENCE:
	result=REMOUT(input)

INPUTS:
	input:	1D array of datapoints

OPTIONAL INPUTS:
	nsig:	FLT number of standard deviations to which to truncate dataset [DEFAULT = 3.0]

KEYWORD PARAMETERS:
	mean:	/mean uses the deviation from the mean instead of the DEFAULT median

OUTPUTS:
	resut:	1D truncated dataset of INPUT where all values lie within +/-NSIG*STDEV 
		of the median (or mean if selected)

OPTIONAL OUTPUTS:
	good:	good=good will be a 1D of size of INPUT which will have 1's for the values kept
		and 0's for the values that were removed.  This can then be used to truncate
		other datasets that depend on INPUT

MODIFICATION HISTORY:
	Written by: 	ML Reinke, 2/21/06

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="RUNS">
<H2>RUNS</H2></A>
<A HREF="#REMOUT">[Previous Routine]</A>
<A HREF="#SAMEAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	RUNS

PURPOSE:
	A handy little function if I can be a little arrogant.  This function takes a list of shots
	and returns a sorted list of run numbers.  This is useful for plotting routines which
	compile data by run number from a non sorted list of shot numbers

CALLLING SEQUENCE:
	result=RUNS(shotlist)

INPUTS:
	shotlist:	LONARR shots
	
OUTPUTS:
	result:		LONARR of runs sorted from lowest to highest

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="SAMEAN">
<H2>SAMEAN</H2></A>
<A HREF="#RUNS">[Previous Routine]</A>
<A HREF="#SUB_BL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	SAMEAN

PURPOSE:
	This function calculates the mean of 'y' in between the xvalues (x0,x1)

CALLING SEQUENCE:
	result=SAMEAN(y,x,x0,x1)

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="SUB_BL">
<H2>SUB_BL</H2></A>
<A HREF="#SAMEAN">[Previous Routine]</A>
<A HREF="#SUM_ARRAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	SUB_BL

PURPOSE:
	This procedure calculates the mean,m, of 'y' in between the xvalues (x0,x1) and returns
	writes over the 'y' with y - m.

CALLING SEQUENCE:
	SUB_BL,y,x,x0,x1

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="SUM_ARRAY">
<H2>SUM_ARRAY</H2></A>
<A HREF="#SUB_BL">[Previous Routine]</A>
<A HREF="#TVZOOM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	SUM_ARRAY	

PURPOSE:
	This function returns the sum of a 2D array summed along the i or j direction

CALLING SEQUENCE:
	result=SUM_ARRAY(array, (/i or /j))

INPUTS:
	array:	Any type of 2D array

OPTIONAL INTPUTS:
	i:	/i to sum in the i-direction 
	j:	/j to sum in the j-direction
	k:	/k to sum in the k-direction
	
RESTRICTIONS:
	The summing in i and j directions only work on 2D arrays.
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="TVZOOM">
<H2>TVZOOM</H2></A>
<A HREF="#SUM_ARRAY">[Previous Routine]</A>
<A HREF="#VALIDSHOTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	TVZOOM
	
PURPOSE:
	This procedure interpolates a given image and redisplays it zoomed in.

CALLING SEQUENCE:
	TVZOOM,image

INPUTS:
	image		FLTARR [n_x,n_y,n_fr] of an image you'd normally TV

OPTIONAL INPUTS:
	zoom:		FLT of the zoom DEFAULT=2
	frame:		INT of the frame number (if n_fr > 0)  DEFAULT = 0
	win:		INT of the window number to plot to.  Will automattically resize for the new image.

MODIFICATION HISTORY:
	Written by:	ML Reinke 12/13/07
	3/17/10:	ML Reinke - added ability to send /true and /norm to TV
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="VALIDSHOTS">
<H2>VALIDSHOTS</H2></A>
<A HREF="#TVZOOM">[Previous Routine]</A>
<A HREF="#VESSEL_PLOT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	VALIDSHOTS

PURPOSE:
	This function will find all the valid shot numbers between a range of run days.
	The main purpose is for running tree stuffing scripts on backlogged data

CALLING SEQUENCE:
	result=VALIDSHOTS(run0,run1)

INPTUS:
	run0:	LONGINT of the starting run
	run1:	LONGINT of ending run

OPTIONAL INPUTS:
	ip:	FLT of the lower level discriminator for the plasma current [kA] to be counted as valid

OUTPUTS:
	result:	LONARR of shot numbers where the spectroscopy tree exists
		No non-shot number values are included

RESTRICTIONS:
	This can't wrap around a year so you have to use the optional input
	and break the job into multiple parts.  I don't think it works for
	years less than 2000 yet, though.

MODIFICATION HISTORY:
	Written by MLReinke (I forget when)
	2-09-06 	MLR - fixed a crashing bug if there were no valid shots
			and added an autodetect to the year and removed optional input
			for the year.
	1-23-08		ML Reinke - added the ip optional input
</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="VESSEL_PLOT">
<H2>VESSEL_PLOT</H2></A>
<A HREF="#VALIDSHOTS">[Previous Routine]</A>
<A HREF="#WAVESTATS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	VESSEL_PLOT

PURPOSE:
	This procedures sends a properly scaled plot of a poloidal C-Mod vacuum vessel/tile cross-section 
	to either the postscript or x-windows device.

CALLING SEQUENCE:
	VESSEL_PLOT

OPTIONAL INPUTS:
	n:		INT:	The window number to plot to
	color:		INT:	Color of the vessel plot lines (not color of plot) DEFAULT: 0
	title:		STR:	String of the plot title DEFAULT: "Alcator C-Mod"
	thick:		INT:	Thickness of the vessel plot lines DEFAULT: 0
	shot:		LON:	Shot number to determine which vessel cross-section to use DEFAULT: 1070510001

KEYWORD PARAMETERS:
	force:		/force will force window number n to reopen and resize it accordingly
	oplot:		/oplot will oplot the vessel structure on the currently selected plotting device
	div:		/div will create a properly scaled zoomed plot of the lower divertor
	edge:		/edge will create a properly scaled zoomed plot of the outer edge

OUTPUTS:
	All outputs are sent to the currently selected plotting device.  VESSEL_PLOTS will do nothing if a device other than
	the X or PS is selected.

PROCEDURE:
	The vessel cross-section plots are taken from Brian Labombard's data files:
			/home/labombard/minicad/vv_tiles_cryo_2007_s.vctr	2007-current
			/home/labombard/minicad/vv_and_tiles_2002_s.vctr   	2002-2007
			/home/labombard/minicad/vacuumvessel.vctr
			/home/labombard/minicad/tiles_2002_s.vctr		1993-2002

MODIFICATION HISTORY:
	Written by:	ML Reinke, Fall 2006
	5-10-07:	ML Reinke - added the new cyropump vessel cross-section and made it the default

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="WAVESTATS">
<H2>WAVESTATS</H2></A>
<A HREF="#VESSEL_PLOT">[Previous Routine]</A>
<A HREF="#WCLOSE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	WAVESTATS

PURPOSE:
	This procedure is duplication of an Igor Pro command line call of the same name
	and is used to print to terminal or a store in a structure a variety of useful
	data for a 1D or 2D input array.  Note that you can type wavestats entirely with
	your left hand.  Neat, huh.

CALLING SEQUENCE:
	WAVESTATS,input

INPTUS:
	input:	ANY NUMERIC array of 1 or 2 dimentions

OPTIONAL OUTPUTS:
	out:	STRUC of all the data that is computed

KEYWORD PARAMETERS:
	quiet:	/quiet to supress terminal outputs

RESTRICTIONS:
	This program used MOMENT to calculate the more significant statistics and 
	calls other MLR_FUNCTIONS routines like MINLOC and MAXLOC (hence the 2D 
	restriction).

EXAMPLE
	WAVESTATS, backround,out=out

	Number of Dim = 2
	Size = [101,20]
	Number of Points = 2020
	Maximum = 1017
	Minimum = 985
	Maxloc = [49,2]
	Minloc = [0,3]
	Average = 1004.6367
	StdDev = 2.8164318
	Var = 7.9322877
	Skew = -2.522629
	Kurt = 14.520065

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="WCLOSE">
<H2>WCLOSE</H2></A>
<A HREF="#WAVESTATS">[Previous Routine]</A>
<A HREF="#WIN_SAVE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	WCLOSE

PURPOSE:
	This closes the given window set.

CALLING SEQUENCE:
	WCLOSE,n

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="WIN_SAVE">
<H2>WIN_SAVE</H2></A>
<A HREF="#WCLOSE">[Previous Routine]</A>
<A HREF="#WRESET">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	WIN_SAVE

PURPOSE:
	This procedure is for times when you need to quickly output a plot that cannot be
	output again to the PS device.  The quaility is poor since it TVRD's to a JPEG.

CALLING SEQUENCE:
	WIN_SAVE,filename_string

RESTRICTIONS
	Operates on currently set window

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
<A NAME="WRESET">
<H2>WRESET</H2></A>
<A HREF="#WIN_SAVE">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
	WRESET

PURPOSE:
	This procedure sets up various window sets used for DATAPLOTS and other MLR plotting routines.
	If the current window set is already open, it does nothing.  Give it a try to see what happens!
	Windows are labeled with what they are generally used for as well as the window number for WSET refernce.

CALLING SEQUENCE:
	WRESET,n

KEYWORD PARAMETERS:
	FORCE:		Use a /force to force a reset of the window set if they are already open

</PRE><P>
<STRONG>(See /usr/local/cmod/idl/GENIE/mlr_functions.pro)</STRONG><P>
<HR>
 
</body>
</html>
