;+
;NAME:
;	READ_ARK_TABLE
;
;PURPOSE:
;	This function reads data from a formatted table generated by M. F. Gu from FAC for
;	modeling line emission from 1s^2-1s2p in He-like argon and 1s-2p in H-like argon
;	including nearby satellites.
;
;CALLING SEQUENCE:
;	result=READ_ARK_TABLE()
;
;OPTIONAL INPUTS:
;	path:	STR of path to directory where TXT file will be loaded and IDL savesets saved or loaded.
;		DEFAULT: /usr/local/cmod/idl/HIREXSR/
;	
;KEYWORD PARAMETERS:
;	new:	/new loads ArK_new.txt rather than ArK.txt
;	kev:	/kev puts the temperature units in keV instead of Kelvin
;	save:	/save will save the output structure as an IDL saveset to path+'/ArK.sav' or +'/ArK_new.sav'
;	load:	/load will load the output structure from path+'/ArK.sav' or +'/ArK_new.sav'
;	debug:	/debug stops the codes in various places
;
;OUTPUTS:
;	result:	STRUC with lots of stuff in it.  The formatting is made to work with other functions, so use it there
;		or ask ML Reinke about it.  I don't want to document the full thing.
;
;MODFICIATION HISTORY:
;	Written by:	ML Reinke 8/08/07
;	12/17/10	M.L. Reinke - changed default path to load from distributed HIREXSR code
;	6/28/12		M.L. Reinke - changed path to load from  GENIE's /atomic_physcs/ directory
;	
;-

FUNCTION read_ark_table,kev=kev,debug=debug,save=save,new=new,load=load,path=path
	kb=8.6173423e-8 	;[keV/kelvin] boltzmann's constant
	IF NOT keyword_set(path) THEN path='/usr/local/cmod/idl/atomic_physics/'	;path='/usr/local/cmod/idl/HIREXSR/'
	IF keyword_set(new) THEN BEGIN
		save_path=path+'ArK_new.sav'
		n_head=1
	ENDIF ELSE BEGIN
		save_path=path+'ArK.sav'
		n_head=15 
	ENDELSE
	IF keyword_set(load) THEN BEGIN
		restore, save_path
		RETURN,ar
	ENDIF
	IF keyword_set(new) THEN filename=path+'ArK_new.txt' ELSE filename=path+'ArK.txt'
	openr,lun,filename,/get_lun
	line=strarr(1)	
	IF keyword_set(new) THEN n_pts=153000 ELSE n_pts=84000

	num_elec=intarr(n_pts)
	low=intarr(n_pts)
	up=intarr(n_pts)
	type=lonarr(n_pts)
	lam=fltarr(n_pts)
	gamma=fltarr(n_pts)
	temp=fltarr(n_pts)
	rec=dblarr(n_pts)
	exc=dblarr(n_pts)
	ion=dblarr(n_pts)
	units=strarr(9)
	IF keyword_set(kev) THEN temp_label='Electron Temp [keV]' ELSE temp_label='Electron Temp [Log10 K]'
	units=['# elec', 'lower level', 'upper level', 'type', 'Wavelength [Ang]', 'decay rate [1/s]', temp_label,$
		'emission from recombination of #elec-1 [m^3/s]', 'emission from excitation #elec [m^3/s]',$
		'emission from ionization of #elec+1 [m^3/s]']
	
	FOR i=0,n_head-1 DO readf,lun,line

	readf,lun,line
	IF keyword_set(debug) THEN stop
	cntr=0L
	WHILE eof(lun) NE 1 DO BEGIN
		tmp=strsplit(line,' ',/extract)
		num_elec[cntr]=int(tmp[0])
		low[cntr]=int(tmp[1])
		up[cntr]=int(tmp[2])
		type[cntr]=long(tmp[3])
		lam[cntr]=float(tmp[4])
		gamma[cntr]=float(tmp[5])
		IF keyword_set(kev) THEN temp[cntr]=10.0^(float(tmp[6]))*kb ELSE temp[cntr]=float(tmp[6])
		rec[cntr]=double(tmp[7])*1.0e-10*1.0e-6	;data is 10^{-10} cm^3/s -> m^3/s
		exc[cntr]=double(tmp[8])*1.0e-10*1.0e-6	;data is 10^{-10} cm^3/s -> m^3/s
		ion[cntr]=double(tmp[9])*1.0e-10*1.0e-6  ;data is 10^{-10} cm^3/s -> m^3/s
		readf,lun,line
		cntr+=1
	ENDWHILE

	close,lun
	free_lun, lun

	tmp=where(lam NE 0)
	output={units:units,num_elec:num_elec[tmp],low:low[tmp],up:up[tmp],type:type[tmp],lam:lam[tmp],gamma:gamma[tmp],$
		temp:temp[tmp],rec:rec[tmp],exc:exc[tmp],ion:ion[tmp]}

	ar=output
	IF keyword_set(save) THEN save,ar,filename=save_path
	IF keyword_set(debug) THEN stop
	RETURN,output
END

;+
;NAME:
;	READ_ARK_LABELS
;
;PURPOSE:
;	This function reads data from a formatted table generated by M. F. Gu from FAC for matching
;	transitions based on NUM_ELEC, LOW and UP to commonly used line labels
;
;CALLING SEQUENCE:
;	result=READ_ARK_LABELS()
;
;OPTIONAL INPUTS:
;	path:	STR of path to directory where TXT file will be loaded and IDL savesets saved or loaded.
;		DEFAULT: /usr/local/cmod/idl/HIREXSR/
;	
;KEYWORD PARAMETERS:
;	save:	/save will save the output structure as an IDL saveset to path+'/ArK_labels.sav'
;	load:	/load will load the output structure from path+'/ArK_labels.sav'
;	debug:	/debug stops the codes in various places
;
;OUTPUTS:
;	result:	STRUC with lots of stuff in it.  The formatting is made to work with other functions, so use it there
;		or ask ML Reinke about it.  I don't want to document the full thing.
;
;MODFICIATION HISTORY:
;	Written by:	ML Reinke 8/08/07
;	12/17/10	M.L. Reinke - changed default path to load from distributed HIREXSR code
;	6/28/12		M.L. Reinke - changed path to load from  GENIE's /atomic_physcs/ directory
;
;-

FUNCTION read_ark_labels,debug=debug,save=save,path=path,load=load
	IF NOT keyword_set(path) THEN path='/usr/local/cmod/idl/atomic_physics/' 	; path='/usr/local/cmod/idl/HIREXSR/'
	IF keyword_set(load) THEN BEGIN
		restore, path+'ArK_labels.sav'
		RETURN,ar_labels
	ENDIF
	filename=path+'ArK_labels.txt'
	openr,lun,filename,/get_lun
	line=strarr(1)

	label=strarr(30)
	num_elec=intarr(30)
	low=intarr(30)
	up=intarr(30)

	readf,lun,line
	IF keyword_set(debug) THEN stop
	cntr=0
	WHILE eof(lun) NE 1 DO BEGIN
		tmp=strsplit(line,' ',/extract)
		label[cntr]=tmp[0]
		num_elec[cntr]=int(tmp[1])
		low[cntr]=int(tmp[2])
		up[cntr]=int(tmp[3])
		readf,lun,line
		cntr+=1
	ENDWHILE

	close,lun
	free_lun, lun

	tmp=where(up NE 0)
	output={label:label[tmp], num_elec:num_elec[tmp], low:low[tmp], up:up[tmp]}
	
	ar_labels=output
	IF keyword_set(save) THEN save,ar_labels,filename=path+'ArK_labels.sav'
	IF keyword_set(debug) THEN stop
	RETURN,output
END

;+
;NAME:
;	REFORM_ARK_DATA
;	
;PURPOSE:
;	This function truncates and reformats the data from READ_ARK_TABLE into a usable subset.  Output
;	format is made to work with other ARK functions.  The /new and /kev keywors are forced.
;
;CALLING SEQUENCE:
;	result=REFORM_ARK_DATA
;	
;INPUTS:
;	del_lam:	FLTARR [low, up] of the wavelength [Ang] region to truncate data set
;	
;OPTIONAL INPUTS:
;	te0:		FLT of the electron temperature [keV] at which to limit line numbers (see PROCEDURE)
;	frac:		FLT of the fraction of emission to include (see PROCEDURE)
;
;KEYWORD PARAMETERS:
;	load:		/load will be sent to READ_ARK_TABLE
;	debug:		/debug stops the code in various places 
;
;OUTPUTS:
;	result:		STRUC of the READ_ARK_TABLE reformatted and truncated to a given wavelength range
;			The useful parts of the structure are described below
;			*.num_elec	FLTARR [n_lines] of the number of electrons from which the line emission is generated
;			*.lam		FLTARR [n_lines] of the rest wavelengths [Ang]
;			*.temp		FLTARR [n_temp]	of the electron temperatures [keV]
;			*.rec		FLTARR [n_temp, n_lines] of the <sigma v> from recombination of num_elec-1 [m^3/s]
;			*.exc		FLTARR [n_temp, n_lines] of the <sigma v> from excitation of num_elec [m^3/s]
;			*.ion		FLTARR [n_temp, n_lines] of the <sigma v> from ionization of num_elec+1 [m^3/s]
;
;OPTIONAL OUTPUTS:
;	ar:		STRUC of the output of READ_ARK_TABLE
;	ERRORS:		-1, -2 and -3 will be returned indicating failures in reformatting the tables (see MLR)
;
;PROCEDURE:
;	The optional inputs te0 and frac can be used to truncate the number of lines to the ones that contribute the most emission.
;	At temperature, te0 the rec, exc and ion rates are added together and the list is sorted and then an integral is formed.
;	The lines that contribute up to frac of the <sigma v> are included.  Without having charge state densities this is a little suspect
;	but should be useful to get most of the emission while still keeping computation times in later functions short.
;
;MODIFICATION HISTORY:
;	Written by:	ML Reinke 8/15/07
;
;-

FUNCTION reform_ark_data,del_lam,load=load,debug=debug,te0=te0,frac=frac,ar=ar
	ar=read_ark_table(load=load,/new,/kev)					;load argon tables for
	
	tmp=where(ar.temp EQ ar.temp[0])					;assume regular te gridding to seperate
	IF tmp[2] NE 2.0*tmp[1] AND tmp[3] NE 3.0*tmp[1] THEN RETURN,-1		;check a couple of lines to be sure
	n_te=tmp[1]

	tmp=where(ar.lam GE del_lam[0] AND ar.lam LE del_lam[1])
	IF tmp[0] EQ -1 THEN RETURN,-2						;if no lines return error
	n_lines=(n(tmp)+1.0)/n_te
	IF keyword_set(debug) THEN stop
	IF n_lines NE floor(n_lines) THEN RETURN, -3				;should have integral number of lines
	
	;define arrays
	units=ar.units
	num_elec=intarr(n_lines)
	low=intarr(n_lines)
	up=intarr(n_lines)
	type=lonarr(n_lines)
	lam=fltarr(n_lines)
	gamma=fltarr(n_lines)
	rec=dblarr(n_te, n_lines)
	exc=dblarr(n_te, n_lines)
	ion=dblarr(n_te, n_lines)
	temp=ar.temp[0:n_te-1]
	
	;reform data and fill arrays
	FOR i=0,n_lines-1 DO BEGIN
		num_elec[i]=ar.num_elec[tmp[i*n_te]]
		low[i]=ar.low[tmp[i*n_te]]
		up[i]=ar.up[tmp[i*n_te]]
		type[i]=ar.type[tmp[i*n_te]]
		lam[i]=ar.lam[tmp[i*n_te]]
		gamma[i]=ar.gamma[tmp[i*n_te]]
		rec[*,i]=ar.rec[tmp[i*n_te:(i+1)*n_te-1]]
		exc[*,i]=ar.exc[tmp[i*n_te:(i+1)*n_te-1]]
		ion[*,i]=ar.ion[tmp[i*n_te:(i+1)*n_te-1]]
	ENDFOR

	;take a subset of the data if desired
	tmp=indgen(n_lines)
	IF keyword_set(te0) AND keyword_set(frac) THEN BEGIN
		i=ipt(temp,te0)
		rates=rec[i,*]+exc[i,*]+ion[i,*]
		index=reverse(sort(rates))
		tot=integ(rates[index])
		j=ipt(tot,max(tot)*frac)
		IF j[0] NE -1 THEN tmp=index[0:j]
	ENDIF

	output={units:units,num_elec:num_elec[tmp],low:low[tmp],up:up[tmp],type:type[tmp],lam:lam[tmp],gamma:gamma[tmp],$
		temp:temp,rec:rec[*,tmp],exc:exc[*,tmp],ion:ion[*,tmp]}
	IF keyword_set(debug) THEN stop
	RETURN,output
END
	
;+
;NAME:
;	READ_AR_LINE_RATES
;
;PURPOSE:
;	This procedure will get the rec, exc and ion rates from the READ_ARK_TABLE data for named transion using READ_ARK_LABELS
;	and produce nicely formatted plots if that's your thing.  /new and /kev are forced in READ_ARK_TABLE.
;
;CALLING SEQUENCE:
;	READ_AR_LINE_RATES,line,te,rec,exc,ion
;	
;INPUTS:
;	line:		STR of the line label - w x y z a b c d e f g h i j k l m n o p q r s t u 
;
;OPTIONAL INPUTS:
;	win:		INT of the window number to plot if /plot is set DEFAULT: 0
;	te_range:	FLTTARR [low, high] of the electron temperature range to plot [keV] DEFAULT: [0.0,5.0]
;
;KEYWORD PARAMETERS:
;	load:		/load is sent to READ_ARK_TABLE and READ_ARK_LABELS
;	plot:		/plot produces a plot all the rates
;	debug:		/debug stops the code in various places
;
;OUTPUTS:
;	te:		FLTARR of the electron temperatures [keV]	
;	rec		FLTARR of the <sigma v> from recombination of num_elec-1 [m^3/s]
;	exc		FLTARR of the <sigma v> from excitation of num_elec [m^3/s]
;	ion		FLTARR of the <sigma v> from ionization of num_elec+1 [m^3/s]
;
;OPTIONAL OUTPUTS:
;	num_elec: 	INT of the number of electrons of the ion where the line emission is coming
;	PLOTS:		A nicely formatted plot of the rates is sent to the current graphics device 
;
;MODIFICATION HISTORY:
;	Written by:	ML Reinke 8/8/07
;
;-		

PRO read_ar_line_rates,line,te,rec,exc,ion,load=load,debug=debug,plot=plot,te_range=te_range,win=win,num_elec=num_elec

	ar_labels=read_ark_labels(load=load)
	ar=read_ark_table(load=load, /new, /kev)
	i=where(ar_labels.label EQ strlowcase(line[0]))			;find matching label
	IF i[0] EQ -1 THEN BEGIN
		print, 'label not found'
		print, ar_labels.labels+' available'
	ENDIF
	low=ar_labels.low[i]
	up=ar_labels.up[i]
	num_elec=ar_labels.num_elec[i]
	tmp=where(ar.low EQ low[0] AND ar.up EQ up[0] AND ar.num_elec EQ num_elec[0])	;find set of data in full structure
	IF keyword_set(debug) THEN stop
	IF tmp[0] EQ -1 THEN BEGIN							;check where statement
		te=-1.0
		rec=-1.0
		exc=-1.0
		ion=-1.0
		RETURN
	ENDIF

	te=ar.temp[tmp]
	rec=ar.rec[tmp]
	exc=ar.exc[tmp]
	ion=ar.ion[tmp]

	;make plot of data if called
	IF keyword_set(plot) THEN BEGIN
		q=18-ar.num_elec[tmp[0]]
		IF NOT keyword_set(te_range) THEN te_range=[0.0,5]
		IF NOT keyword_set(win) THEN win=0
		openwin,win
		tmp=where(te GE te_range[0] AND te LE te_range[1])
		ymax=max(rec[tmp]) > max(ion[tmp]) > max(exc[tmp])
		plot, [0],[0], xr=[te_range[0], te_range[1]], /xsty, xtit='Electron Temperature [keV]',$
			yr=[0.0,ymax*1.1],/ysty, ytit='<'+n2g('sigma')+'v> [m!u3!n/s]',chars=1.3,tit='Rates For Ar '+strupcase(line)+' Line'
		oplot, te[tmp], exc[tmp]
		oplot, te[tmp], rec[tmp],color=100
		oplot, te[tmp], ion[tmp],color=200
		xyouts,0.5, 0.9*ymax,'+'+num2str(q+1,1),color=100,chars=1.2
		xyouts,0.5, 0.8*ymax,'+'+num2str(q,1),color=0,chars=1.2
		xyouts,0.5, 0.7*ymax,'+'+num2str(q-1,1),color=200,chars=1.2
	ENDIF
END

;+
;NAME:
;	CALC_AR_LINE_RATES:
;	
;PURPOSE:
;	This procedure calculates the various rates for a given line at input Te values by interpolating
;	READ_AR_LINE_RATES data.  A /load is forced.
;	
;CALLING SEQUENCE:
;	CALC_AR_LINE_RATES,line,te,q,rates
;	
;INPUTS:
;	line:		STR of the line label - w x y z a b c d e f g h i j k l m n o p q r s t u 	
;	te:		FLATRR [n_te] of electron temperature values [keV]
;
;OUTPUTS:
;	q:		FLTARR 	[3] of the [rec, exc, ion] charge states, ie Ar+##
;	rates:		FLATARR [3,n_te] where
;				[0,*] of the <sigma v> from recombination of num_elec-1 [m^3/s]
;				[1,*] of the <sigma v> from excitation of num_elec [m^3/s]
;				[2,*] of the <sigma v> from ionization of num_elec+1 [m^3/s]
;
;MODIFICIATION HISTORY:
;	Written by:	ML Reinke 8/8/07
;
;-

PRO calc_ar_line_rates,line,te,q,rates
	
	read_ar_line_rates,line,te_data,rec,exc,ion,num_elec=num_elec,/load
	rates=fltarr(3,n(te)+1)
	rates[0,*]=interpol(rec,te_data,te)
	rates[1,*]=interpol(exc,te_data,te)
	rates[2,*]=interpol(ion,te_data,te)
	q=[1,0,-1]+18-num_elec[0]
END

;+
;NAME:
;	CALC_RATIO
;
;PURPOSE:
;	This procedure calculates the ratio of a group (or one) of numerator and demonator lines as a function of Te
;
;CALLING SEQUENCE:
;	CALC_RATIO,num_lines,dem_lines,cs,te,ratio
;
;INPUTS
;	num_lines:	STRARR of the lines to include in the numerator
;	dem_lines:	STRARR of the lines to include in the denominator
;	cs:		INT of the common charge state from which to take each lines' rate
;
;OUTPUTS:
;	te:		FLTARR of the te values [keV]
;	ratio:		FLATRR of the line ratio
;
;MODIFICATION HISTORY:
;	Written by:	ML Reinke 8/8/07
;
;-

PRO calc_ratio,num_lines,dem_lines,cs,te,ratio
	
	FOR i=0,n(num_lines) DO BEGIN
		read_ar_line_rates,num_lines[i],te,rec,exc,ion,num_elec=num_elec,/load
		IF i EQ 0 THEN num=fltarr(n(te)+1)
		q=[1,0,-1]+18-num_elec[0]
		tmp=where(q EQ cs)
		CASE tmp[0] OF
			-1 : data=fltarr(n(te)+1)
			0  : data=rec
			1  : data=exc
			2  : data=ion
		ENDCASE
		num+=data
	ENDFOR

	FOR i=0,n(dem_lines) DO BEGIN
		read_ar_line_rates,dem_lines[i],te,rec,exc,ion,num_elec=num_elec,/load
		IF i EQ 0 THEN dem=fltarr(n(te)+1)
		q=[1,0,-1]+18-num_elec[0]
		tmp=where(q EQ cs)
		CASE tmp[0] OF
			-1 : data=fltarr(n(te)+1)
			0  : data=rec
			1  : data=exc
			2  : data=ion
		ENDCASE
		dem+=data
	ENDFOR
	ratio=num/dem
END

;+
;NAME:
;	ARK2EMISS_LINE
;	
;PURPOSE:
;	This procedure turns data from MIST and REFORM_ARK_DATA and turns it into an EMISS structure which
;	is formatted for GENSPEC_GPV2SPECTRA INPUT.
;
;CALLING SEQUENCE:
;	ARK2EMISS_LINE,ar,csden,nel,te,rad,time,emiss,line
;	
;INPUTS
;	ar:	STRUC 	output of REFORM_ARK_DATA for arbitary values
;	csden:	FLTARR 	[19,n_rad] of the charge state density profiles where [18,*] is fully stripped and [0,*] is neutral [10^20 /m^3]
;	nel:	FLTARR 	[n_rad] of the electron density profile [10^20 /m^3]
;	te:	FLTARR 	[n_rad] of the electron temperature profile [keV]
;	rad:	FLATRR 	[n_rad] of the major radius points [m]
;	time:	FLT	of the time point where the profiles have been determined [sec] (passed directly to output)
;
;KEYWORD PARAMETERS:
;	debug:	/debug stops the code before the end
;
;OUTPUTS:
;	emiss:	STRUC containing the line emissivity and its spatial/temporal information
;		*.emiss	FLTARR [n_rad,n_lines] of the line emissivity [ph/s/m^3]
;		*.r	FLTARR of the midplane major radii of emiss
;		*.t	FLTARR of the time point [sec]
;	line:	STRUC containing information about the line to be calculated
;		*.lam_o		FLTARR [n_lines] the rest wavelengtsh of the linse
;		*.del_lam	FLT used in the wavelength interval
;		*.mass		FLT the mass of ion in AMU
;
;MODIFICATION HISTORY:
;	Written by:	ML Reinke 8-15-07
;
;-		

PRO ark2emiss_line,ar,csden,nel,te,rad,time,emiss,line,debug=debug
	z=18
	n_lines=n(ar.lam)+1
	n_rad=n(rad)+1
	em=fltarr(n_rad,n_lines)
	lam_o=fltarr(n_lines)
	FOR i=0,n_lines-1 DO BEGIN
		cs=z-ar.num_elec[i]
		rec_interp=interpol(ar.rec[*,i],ar.temp,te)
		exc_interp=interpol(ar.exc[*,i],ar.temp,te)
		ion_interp=interpol(ar.ion[*,i],ar.temp,te)
		em[*,i]=nel*1.0e20*(csden[cs+1,*]*rec_interp+csden[cs,*]*exc_interp+csden[cs-1,*]*ion_interp)*1.0e20
		lam_o[i]=ar.lam[i]
	ENDFOR
	mass=read_atomic_mass(z)
	del_lam=5.0*lam_o[0]*sqrt(max(te)*1.0e3*1.6e-19/(mass*1.66e-27))/3.0e8
        line={lam_o:lam_o,del_lam:del_lam[0], mass:mass}
	emiss={emiss:em, r:rad, t:fltarr(1)+time}
	
	IF keyword_set(debug) THEN stop
END

;+
;NAME:
;	MIST_ARK_INPUT_DATA
;
;PURPOSE:
;	This procedure calculates and saves the input data necessary for GENSPEC_GPV2SPECTRA using data from
;	READ_ARK_TABLES and MIST.
;
;CALLING SEQUCNE:
;	MIST_ARK_INPUT_DATA,shot,time,lr
;
;INPUTS:
;	shot:	LON 	shot number
;	time:	FLT 	time point [sec]
;	lr:	FLTARR [low,high] of the wavelength interval for which to create saveset
;
;OPTIONAL INPUTS:
;	te0:	FLT value sent to REFORM_ARK_DATA DEFAULT: 2.0
;	frac:	FLT value sent to REFORM_ARK_DATA DEFAULT: 0.925
;	path:	STR of the path to save data file DEFAULT: /home/mlreinke/idl/genie/data/mist/mist_ark_data.sav
;	tres:	FLT value sent to MIST DEFAULT: 0.1
;	
;KEYWORD PARAMETERS:
;	debug:	/debug stopes the code in various places
;	MIST: 	/h_mdoe, /thomson, /hullac, /mverb (/fit and /local are DEFAULTS)
;
;OUTPUTS:
;	A saveset at path is created that holds a MIST structure of mist.emiss, mist.vel mist.ti and mist.line
;	formatted for GENSPEC_GPV2SPECTRA.  The shot number, time and z are also included.
;	
;	***all velocity profiles are set to zero***
;
;
;MODIFICATION HISTORY:
;	Written by:	ML Reinke 8/15/07
;
;-

PRO mist_ark_input_data, shot,time,lr,debug=debug,te0=te0,frac=frac,path=path,$		;PRIMARY
                     	 h_mode=h_mode,thomson=thomson, hullac=hullac,tres=tres		;MIST	

	IF NOT keyword_set(path) THEN path='/home/mlreinke/idl/genie/data/mist/mist_ark_data.sav'
	z=18
	IF NOT keyword_set(te0) THEN te0=2.0
	IF NOT keyword_set(frac) THEN frac=0.925
	ar=reform_ark_data(lr,/load,te0=te0,frac=frac)

	;setup MIST optional inputs and keywords
	IF NOT keyword_set(tres) THEN tres=0.1
        IF NOT keyword_set(hullac) THEN local=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN tefit=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN nefit=1
	tau=time	

        ;run MIST
	zz_uncalibrated_mist,z,shot,time,tres,lam,qlam,radpts,em,csden,h_mode=h_mode,tefit=tefit,nefit=nefit,local=local,$
		te_profile=te,ne_profile=nel
        IF keyword_set(debug) THEN stop

	time=[time]
        ;setup emissivity structure and line structure from ArK data
  	ark2emiss_line,ar,csden,nel,te,radpts,time,emiss,line

        ;setup velocity structure if not specified by input
	IF NOT keyword_set(vel) THEN vel=0.0
        IF size(vel, /type) NE 8 THEN BEGIN
		u=fltarr(51)
		w=fltarr(51)
		vel={u:u,w:w,r:radpts,t:time}
	ENDIF

        ;setup ion temperature structure
        ti={ti:te, r:radpts, t:time}

	time=tau

        output={emiss:emiss,ti:ti,vel:vel,line:line}
	mist=output
	save,mist,shot,time,z,filename=path
	IF keyword_set(debug) THEN stop
END


PRO plot_group_ratio, num_lr, dem_lr,cs=cs,ce=ce,debug=debug

	z=18
	ar_num=reform_ark_data(num_lr,/load)
	ar_dem=reform_ark_data(dem_lr,/load)

	te=ar_num.temp
	n_te=n(te)+1
	i_te=ipt(te,6.0)
	n_lines=n(ar_num.num_elec)+1
	print, n_lines
	num_rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar_num.num_elec[i]
		num_rates[q+1,*]+=ar_num.rec[*,i]
		num_rates[q,*]+=ar_num.exc[*,i]
		num_rates[q-1,*]+=ar_num.ion[*,i]
	ENDFOR
	openwin,0
	no_sig=intarr(19)
	FOR i=0,18 DO IF total(num_rates[i,*]) EQ 0 THEN no_sig[i]=1.0
	tmp=where(no_sig EQ 0.0)
	maxpt=max(num_rates[*,0:i_te])*1.0e17
	colors=[30,200,0.0,100]
	plot, [0],[0], xr=[0.0,6.0],yr=[0.0,maxpt*1.1],xtit='Electron Temperature [keV]', ytit='<'+n2g('sigma')+'v> [10!u-17!n m!u3!n/s]',$
		chars=1.3,tit='NUM Line Group: '+num2str(num_lr[0],dp=4)+' - '+num2str(num_lr[1],dp=4),/ysty,/xsty
	FOR i=0,n(tmp) DO BEGIN
		oplot, te, num_rates[tmp[i],*]*1.0e17,color=colors[i]
		xyouts,0.5, (0.5+0.075*i)*maxpt,'+'+num2str(tmp[i],1),color=colors[i],chars=1.2
	ENDFOR

	n_lines=n(ar_dem.num_elec)+1
	print, n_lines
	dem_rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar_dem.num_elec[i]
		dem_rates[q+1,*]+=ar_dem.rec[*,i]
		dem_rates[q,*]+=ar_dem.exc[*,i]
		dem_rates[q-1,*]+=ar_dem.ion[*,i]
	ENDFOR
	openwin,1
	no_sig=intarr(19)
	FOR i=0,18 DO IF total(dem_rates[i,*]) EQ 0 THEN no_sig[i]=1.0
	tmp=where(no_sig EQ 0.0)
	maxpt=max(dem_rates[*,0:i_te])*1.0e17
	colors=[150,30,200,0.0,100]
	plot, [0],[0], xr=[0.0,6.0],yr=[0.0,maxpt*1.1],xtit='Electron Temperature [keV]', ytit='<'+n2g('sigma')+'v> [10!u-17!n m!u3!n/s]',$
		chars=1.3,tit='DEM Line Group: '+num2str(dem_lr[0],dp=4)+' - '+num2str(dem_lr[1],dp=4),/ysty,/xsty
	FOR i=0,n(tmp) DO BEGIN
		oplot, te, dem_rates[tmp[i],*]*1.0e17,color=colors[i]
		xyouts,0.5, (0.5+0.075*i)*maxpt,'+'+num2str(tmp[i],1),color=colors[i],chars=1.2
	ENDFOR

	IF keyword_set(cs) OR keyword_set(ce) THEN BEGIN
		openwin,2
		IF keyword_set(ce) THEN BEGIN
			fq,z,frac,te_fq
			te_fq*=1.0e-3
			num=fltarr(n_te)
			dem=fltarr(n_te)
			FOR i=0,z DO BEGIN
				num+=num_rates[i,*]*interpol(frac[i,*],te_fq,te)
				dem+=dem_rates[i,*]*interpol(frac[i,*],te_fq,te)
			ENDFOR
			ratio=num/dem
			te=te[where(te GE te_fq[0] AND te LE te_fq[n(te_fq)])]
			ratio=ratio[where(te GE te_fq[0] AND te LE te_fq[n(te_fq)])]
			tmp=where(ratio < 0)
			IF tmp[0] NE -1 THEN ratio[tmp]=0.0
			tit='Line Ratio vs. T!le!n Assuming CE'
		ENDIF ELSE BEGIN
			ratio=num_rates[cs,*]/dem_rates[cs,*]
			tit='Line Ratio vs. T!le!n Assuming +'+num2str(cs,1)
		ENDELSE
		makesym,10
		maxpt=max(ratio[7:i_te])
		plot, te, ratio, xr=[0.0,6.0],psym=-8,symsize=1.25,thick=2.0,xtit='Electron Temperature [keV]', ytit='NUM/DEM', $
			tit=tit,chars=1.3,yr=[0.0,maxpt],/ysty,/xsty
	ENDIF
	IF keyword_set(debug) THEN stop
END

PRO calc_group_ratio,num_lr,dem_lr,cs,te,ratio,ce=ce,debug=debug
	z=18
	ar_num=reform_ark_data(num_lr,/load)
	ar_dem=reform_ark_data(dem_lr,/load)

	te=ar_num.temp
	n_te=n(te)+1

	n_lines=n(ar_num.num_elec)+1
	num_rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar_num.num_elec[i]
		num_rates[q+1,*]+=ar_num.rec[*,i]
		num_rates[q,*]+=ar_num.exc[*,i]
		num_rates[q-1,*]=ar_num.ion[*,i]
	ENDFOR

	n_lines=n(ar_dem.num_elec)+1
	dem_rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar_dem.num_elec[i]
		dem_rates[q+1,*]+=ar_dem.rec[*,i]
		dem_rates[q,*]+=ar_dem.exc[*,i]
		dem_rates[q-1,*]+=ar_dem.ion[*,i]
	ENDFOR

	IF keyword_set(ce) THEN BEGIN
		fq,z,frac,te_fq
		te_fq*=1.0e-3
		num=fltarr(n_te)
		dem=fltarr(n_te)
		FOR i=0,z DO BEGIN
			num+=num_rates[i,*]*interpol(frac[i,*],te_fq,te)
			dem+=dem_rates[i,*]*interpol(frac[i,*],te_fq,te)
		ENDFOR
		ratio=num/dem
		te=te[where(te GE te_fq[0] AND te LE te_fq[n(te_fq)])]
		ratio=ratio[where(te GE te_fq[0] AND te LE te_fq[n(te_fq)])]
		tmp=where(ratio < 0)
		IF tmp[0] NE -1 THEN ratio[tmp]=0.0
	ENDIF ELSE ratio=reform(num_rates[cs,*]/dem_rates[cs,*])
	IF keyword_set(debug) THEN stop
END

PRO calc_group_rates, lr, te, rates
	z=18
	ar=reform_ark_data(lr,/load)

	te=ar.temp
	n_te=n(te)+1

	n_lines=n(ar.num_elec)+1
	rates=fltarr(z+1,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar.num_elec[i]
		rates[q+1,*]+=ar.rec[*,i]
		rates[q,*]+=ar.exc[*,i]
		rates[q-1,*]+=ar.ion[*,i]
	ENDFOR

	IF keyword_set(debug) THEN stop
END

PRO calc_zw_ratio,xyw_ratio,te,ratio
	
	n_xyw=n(xyw_ratio)+1

	num_z=[3.987,4.0]
	num_xy=[3.965,3.975]
	num_w=[3.94,3.96]
	
	ar_w=reform_ark_data(num_w,/load)
	ar_xy=reform_ark_data(num_xy,/load)
	ar_z=reform_ark_data(num_z,/load)
	te=ar_w.temp
	n_te=n(te)+1
	z=18

	n_lines=n(ar_w.num_elec)+1
	w_rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar_w.num_elec[i]
		w_rates[q+1,*]+=ar_w.rec[*,i]
		w_rates[q,*]+=ar_w.exc[*,i]
		w_rates[q-1,*]=ar_w.ion[*,i]
	ENDFOR

	n_lines=n(ar_xy.num_elec)+1
	xy_rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar_xy.num_elec[i]
		xy_rates[q+1,*]+=ar_xy.rec[*,i]
		xy_rates[q,*]+=ar_xy.exc[*,i]
		xy_rates[q-1,*]=ar_xy.ion[*,i]
	ENDFOR
	
	n_lines=n(ar_z.num_elec)+1
	z_rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar_z.num_elec[i]
		z_rates[q+1,*]+=ar_z.rec[*,i]
		z_rates[q,*]+=ar_z.exc[*,i]
		z_rates[q-1,*]=ar_z.ion[*,i]
	ENDFOR
	ratio=fltarr(n_te,n_xyw)
	FOR j=0,n_xyw-1 DO ratio[*,j]=(z_rates[16,*]+z_rates[17,*]/xy_rates[17,*]*(xyw_ratio[j]*w_rates[16,*]-xy_rates[16,*]))/w_rates[16,*]
	IF keyword_set(debug) THEN stop
END

FUNCTION calc_group_emiss,lr,csden,nel,te,debug=debug,emiss=emiss
	z=18
	n_te=n(te)+1
	ar=reform_ark_data(lr,/load)
	n_lines=n(ar.num_elec)+1
	rates=fltarr(19,n_te)
	FOR i=0,n_lines-1 DO BEGIN
		q=z-ar.num_elec[i]
		rates[q+1,*]+=interpol(ar.rec[*,i],ar.temp,te)
		rates[q,*]+=interpol(ar.exc[*,i],ar.temp,te)
		rates[q-1,*]+=interpol(ar.ion[*,i],ar.temp,te)
	ENDFOR

	emiss=fltarr(19, n_te)
	FOR i=0,18 DO emiss[i,*]=nel*1.0e20*rates[i,*]*csden[i,*]*1.0e20

	output=reform(sum_array(emiss,/j))
	IF keyword_set(debug) THEN stop
	RETURN,output
END

FUNCTION calc_te_profile,shot,time,h_mode=h_mode,thomson=thomson, hullac=hullac,tres=tres,debug=debug,plots=plots,$
		num_lr=num_lr, dem_lr=dem_lr,ce=ce,cs=cs

	IF NOT keyword_set(num_lr) THEN num_lr=[3.94,3.96]
	IF NOT keyword_set(dem_lr) THEN dem_lr=[3.987,3.992]
	z=18
	IF NOT keyword_set(cs) THEN cs=16

	;setup MIST optional inputs and keywords
	IF NOT keyword_set(tres) THEN tres=0.1
        IF NOT keyword_set(hullac) THEN local=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN tefit=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN nefit=1

	;run MIST
	zz_uncalibrated_mist,z,shot,time,tres,lam,qlam,radpts,em,csden,h_mode=h_mode,tefit=tefit,nefit=nefit,local=local,$
		te_profile=te,ne_profile=nel
        IF keyword_set(debug) THEN stop

	num_emiss=calc_group_emiss(num_lr,csden,nel,te,emiss=num_rates)
	dem_emiss=calc_group_emiss(dem_lr,csden,nel,te,emiss=dem_rates)

	em_ratio=num_emiss/dem_emiss
	calc_group_ratio,num_lr, dem_lr,cs,te_rat,ratio,ce=ce
	ratio=ratio[where(te_rat GT 0.1)]
	te_rat=te_rat[where(te_rat GT 0.1)]
	em_te=interpol(te_rat,ratio,em_ratio)

	IF keyword_set(plots) THEN BEGIN
		openwin,0
		no_sig=intarr(19)
		FOR i=0,18 DO IF total(num_rates[i,*]) EQ 0 THEN no_sig[i]=1.0
		tmp=where(no_sig EQ 0.0)
		maxpt=max(num_rates)*1.0e-20
		colors=[30,200,0.0,100]
		plot, [0],[0],xr=[0.67,0.91],yr=[0.0,maxpt*1.1],xtit='Major Radius [m]', ytit='Emissivity [10!u20!n ph/m!u3!n/s]',$
			chars=1.3,tit='NUM Line Group: '+num2str(num_lr[0],dp=4)+' - '+num2str(num_lr[1],dp=4),/ysty,/xsty
		FOR i=0,n(tmp) DO BEGIN
			oplot, radpts, num_rates[tmp[i],*]*1.0e-20,color=colors[i]
			xyouts,0.87, (0.5+0.075*i)*maxpt,'+'+num2str(tmp[i],1),color=colors[i],chars=1.2
		ENDFOR
		xyouts,0.9,0.1*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2),orient=90.0

		openwin,1
		no_sig=intarr(19)
		FOR i=0,18 DO IF total(dem_rates[i,*]) EQ 0 THEN no_sig[i]=1.0
		tmp=where(no_sig EQ 0.0)
		maxpt=max(dem_rates)*1.0e-20
		colors=[150,30,200,0.0,100]
		plot, [0],[0],xr=[0.67,0.91],yr=[0.0,maxpt*1.1],xtit='Major Radius [m]', ytit='Emissivity [10!u20!n ph/m!u3!n/s]',$
			chars=1.3,tit='DEM Line Group: '+num2str(dem_lr[0],dp=4)+' - '+num2str(dem_lr[1],dp=4),/ysty,/xsty
		FOR i=0,n(tmp) DO BEGIN
			oplot, radpts, dem_rates[tmp[i],*]*1.0e-20,color=colors[i]
			xyouts,0.87, (0.5+0.075*(i-1))*maxpt,'+'+num2str(tmp[i],1),color=colors[i],chars=1.2
		ENDFOR
		xyouts,0.9,0.1*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2),orient=90.0

		openwin,2
		makesym,10
		maxpt=max(te)
		plot, te, em_te, xtit='Input Electron Temperature [keV]', ytit='T!le!n from Ratio [keV]',psym=8,symsize=1.2,chars=1.3,$
			yr=[0.0,maxpt],xr=[0.0,maxpt],/xsty,/ysty,tit='Quality of Temperature Prediction'
		xyouts,0.1*maxpt,0.9*maxpt,'NUM: ['+num2str(num_lr[0],dp=4)+' - '+num2str(num_lr[1],dp=4)+']',chars=1.2
		xyouts,0.1*maxpt,0.8*maxpt,'DEM: ['+num2str(dem_lr[0],dp=4)+' - '+num2str(dem_lr[1],dp=4)+']',chars=1.2
		oplot,[0,10],[0,10],color=200,linestyle=2, thick=2.0
		xyouts,0.5*maxpt,0.05*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2)
	ENDIF

	output={in:te, out:em_te}
	IF keyword_set(debug) THEN stop
	RETURN,output
END

	
FUNCTION calc_wxyz_te_profile,shot,time,h_mode=h_mode,thomson=thomson, hullac=hullac,tres=tres,debug=debug,plots=plots
	num_z=[3.987,4.0]
	num_xy=[3.965,3.975]
	num_w=[3.94,3.96]
	z=18

	;setup MIST optional inputs and keywords
	IF NOT keyword_set(tres) THEN tres=0.1
        IF NOT keyword_set(hullac) THEN local=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN tefit=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN nefit=1

	;run MIST
	zz_uncalibrated_mist,z,shot,time,tres,lam,qlam,radpts,em,csden,h_mode=h_mode,tefit=tefit,nefit=nefit,local=local,$
		te_profile=te,ne_profile=nel
        IF keyword_set(debug) THEN stop

	w_emiss=calc_group_emiss(num_w,csden,nel,te,emiss=w_rates)
	xy_emiss=calc_group_emiss(num_xy,csden,nel,te,emiss=xy_rates)
	z_emiss=calc_group_emiss(num_z,csden,nel,te,emiss=z_rates)

	zw_ratio=z_emiss/w_emiss
	xyw_ratio=xy_emiss/w_emiss
	calc_zw_ratio,xyw_ratio,te_rat,ratio
	n_ratio=n(zw_ratio)+1
	em_te=fltarr(n_ratio)
	FOR i=0,n_ratio-1 DO em_te[i]=interpol(te_rat,ratio[*,i],zw_ratio[i])

	IF keyword_set(plots) THEN BEGIN
		openwin,0
		no_sig=intarr(19)
		FOR i=0,18 DO IF total(w_rates[i,*]) EQ 0 THEN no_sig[i]=1.0
		tmp=where(no_sig EQ 0.0)
		maxpt=max(w_rates)*1.0e-20
		colors=[30,200,0.0,100]
		plot, [0],[0],xr=[0.67,0.91],yr=[0.0,maxpt*1.1],xtit='Major Radius [m]', ytit='Emissivity [10!u20!n ph/m!u3!n/s]',$
			chars=1.3,tit='W Line Group: '+num2str(num_w[0],dp=4)+' - '+num2str(num_w[1],dp=4),/ysty,/xsty
		FOR i=0,n(tmp) DO BEGIN
			oplot, radpts, w_rates[tmp[i],*]*1.0e-20,color=colors[i]
			xyouts,0.87, (0.5+0.075*i)*maxpt,'+'+num2str(tmp[i],1),color=colors[i],chars=1.2
		ENDFOR
		xyouts,0.9,0.1*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2),orient=90.0

		openwin,1
		no_sig=intarr(19)
		FOR i=0,18 DO IF total(xy_rates[i,*]) EQ 0 THEN no_sig[i]=1.0
		tmp=where(no_sig EQ 0.0)
		maxpt=max(xy_rates)*1.0e-20
		colors=[150,30,200,0.0,100]
		plot, [0],[0],xr=[0.67,0.91],yr=[0.0,maxpt*1.1],xtit='Major Radius [m]', ytit='Emissivity [10!u20!n ph/m!u3!n/s]',$
			chars=1.3,tit='XY Line Group: '+num2str(num_xy[0],dp=4)+' - '+num2str(num_xy[1],dp=4),/ysty,/xsty
		FOR i=0,n(tmp) DO BEGIN
			oplot, radpts, xy_rates[tmp[i],*]*1.0e-20,color=colors[i]
			xyouts,0.87, (0.5+0.075*(i-1))*maxpt,'+'+num2str(tmp[i],1),color=colors[i],chars=1.2
		ENDFOR
		xyouts,0.9,0.1*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2),orient=90.0

		openwin,2
		no_sig=intarr(19)
		FOR i=0,18 DO IF total(z_rates[i,*]) EQ 0 THEN no_sig[i]=1.0
		tmp=where(no_sig EQ 0.0)
		maxpt=max(z_rates)*1.0e-20
		colors=[150,30,200,0.0,100]
		plot, [0],[0],xr=[0.67,0.91],yr=[0.0,maxpt*1.1],xtit='Major Radius [m]', ytit='Emissivity [10!u20!n ph/m!u3!n/s]',$
			chars=1.3,tit='Z Line Group: '+num2str(num_z[0],dp=4)+' - '+num2str(num_z[1],dp=4),/ysty,/xsty
		FOR i=0,n(tmp) DO BEGIN
			oplot, radpts, z_rates[tmp[i],*]*1.0e-20,color=colors[i]
			xyouts,0.87, (0.5+0.075*(i-1))*maxpt,'+'+num2str(tmp[i],1),color=colors[i],chars=1.2
		ENDFOR
		xyouts,0.9,0.1*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2),orient=90.0

		openwin,3
		makesym,10
		maxpt=max(te)
		plot, te, em_te, xtit='Input Electron Temperature [keV]', ytit='T!le!n from Ratio [keV]',psym=8,symsize=1.2,chars=1.3,$
			yr=[0.0,maxpt],xr=[0.0,maxpt],/xsty,/ysty,tit='Quality of Temperature Prediction'
		xyouts,0.1*maxpt,0.9*maxpt,'NUM: ['+num2str(num_xy[0],dp=4)+' - '+num2str(num_xy[1],dp=4)+']',chars=1.2
		xyouts,0.1*maxpt,0.8*maxpt,'DEM: ['+num2str(num_w[0],dp=4)+' - '+num2str(num_w[1],dp=4)+']',chars=1.2
		oplot,[0,10],[0,10],color=200,linestyle=2, thick=2.0
		xyouts,0.5*maxpt,0.05*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2)
	ENDIF

	output={in:te, out:em_te}
	IF keyword_set(debug) THEN stop
	RETURN,output
END

FUNCTION calc_tecs_profile,shot,time,h_mode=h_mode,thomson=thomson, hullac=hullac,tres=tres,debug=debug,plots=plots,$
		num_a_lr=num_a_lr, num_b_lr=num_b_lr, dem_lr=dem_lr

	IF NOT keyword_set(num_a_lr) THEN num_a_lr=[3.94,3.96]
	IF NOT keyword_set(num_b_lr) THEN num_b_lr=[3.965,3.975]
	IF NOT keyword_set(num_c_lr) THEN num_c_lr=[3.987,4.00]
	IF NOT keyword_set(dem_lr) THEN dem_lr=[3.987,3.992]
	z=18

	;setup MIST optional inputs and keywords
	IF NOT keyword_set(tres) THEN tres=0.1
        IF NOT keyword_set(hullac) THEN local=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN tefit=1
        IF is_fit(shot) AND NOT keyword_set(thomson) THEN nefit=1

	;run MIST
	zz_uncalibrated_mist,z,shot,time,tres,lam,qlam,radpts,em,csden,h_mode=h_mode,tefit=tefit,nefit=nefit,local=local,$
		te_profile=te,ne_profile=nel
        IF keyword_set(debug) THEN stop

	num_a_emiss=calc_group_emiss(num_a_lr,csden,nel,te)
	num_b_emiss=calc_group_emiss(num_b_lr,csden,nel,te)
	num_c_emiss=calc_group_emiss(num_c_lr,csden,nel,te)
	dem_emiss=calc_group_emiss(dem_lr,csden,nel,te,emiss=dem_rates)
	n_ratio=n(dem_emiss)+1

	a_ratio=num_a_emiss/dem_emiss
	calc_group_ratio,num_a_lr, dem_lr,16,te_rat,ratio
	em_te=interpol(te_rat,ratio,a_ratio)

	b_ratio=num_b_emiss/dem_emiss
	tmp=where(radpts GT 0.87)
	IF tmp[0] NE -1 THEN b_ratio[tmp]=0.0
	calc_group_rates,num_b_lr,te_rat,num_b_rates
	calc_group_rates,dem_lr,te_rat,dem_rates
	n17_16=(b_ratio*interpol(dem_rates[16,*],te_rat,em_te)-interpol(num_b_rates[16,*],te_rat,em_te))/$
		interpol(num_b_rates[17,*],te_rat,em_te)
	IF tmp[0] NE -1 THEN n17_16[tmp]=0.0
	
	c_ratio=num_c_emiss/dem_emiss
	calc_group_rates,num_c_lr,te_rat,num_c_rates
	em_te_new=fltarr(n_ratio)
	tmp=where(te_rat GT 0.7)
	FOR i=0,n_ratio-1 DO em_te_new[i]=interpol(te_rat[tmp],$
		(num_c_rates[16,tmp]+n17_16[i]*num_c_rates[17,tmp])/dem_rates[16,tmp], c_ratio[i])
	

	IF keyword_set(plots) THEN BEGIN
		openwin,0
		makesym,10
		maxpt=max(te)
		plot, te, em_te, xtit='Input Electron Temperature [keV]', ytit='T!le!n from Ratio [keV]',psym=8,symsize=1.2,chars=1.3,$
			yr=[0.0,maxpt],xr=[0.0,maxpt],/xsty,/ysty,tit='First Temperature Prediction'
		xyouts,0.1*maxpt,0.9*maxpt,'NUM: ['+num2str(num_a_lr[0],dp=4)+' - '+num2str(num_a_lr[1],dp=4)+']',chars=1.2
		xyouts,0.1*maxpt,0.8*maxpt,'DEM: ['+num2str(dem_lr[0],dp=4)+' - '+num2str(dem_lr[1],dp=4)+']',chars=1.2
		oplot,[0,10],[0,10],color=200,linestyle=2, thick=2.0
		xyouts,0.5*maxpt,0.05*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2)

		openwin,1
		makesym,10
		maxpt=max(n17_16)
		plot, csden[17,*]/csden[16,*],n17_16, xtit='Input n!l17!n/n!l16!n', ytit=' n!l17!n/n!l16!n From Ratio',psym=8,symsize=1.2,$
			chars=1.3,yr=[0.0,maxpt],xr=[0.0,maxpt],/xsty,/ysty,tit='CS Ratio Prediction'
		xyouts,0.1*maxpt,0.9*maxpt,'NUM: ['+num2str(num_b_lr[0],dp=4)+' - '+num2str(num_b_lr[1],dp=4)+']',chars=1.2
		xyouts,0.1*maxpt,0.8*maxpt,'DEM: ['+num2str(dem_lr[0],dp=4)+' - '+num2str(dem_lr[1],dp=4)+']',chars=1.2
		oplot,[0,10],[0,10],color=200,linestyle=2, thick=2.0
		xyouts,0.5*maxpt,0.05*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2)

		openwin,2
		makesym,10
		maxpt=max(te)
		plot, te, em_te_new, xtit='Input Electron Temperature [keV]', ytit='T!le!n from Ratio [keV]',psym=8,symsize=1.2,chars=1.3,$
			yr=[0.0,maxpt],xr=[0.0,maxpt],/xsty,/ysty,tit='Second of Temperature Prediction Using CSDEN'
		xyouts,0.1*maxpt,0.9*maxpt,'NUM: ['+num2str(num_c_lr[0],dp=4)+' - '+num2str(num_c_lr[1],dp=4)+']',chars=1.2
		xyouts,0.1*maxpt,0.8*maxpt,'DEM: ['+num2str(dem_lr[0],dp=4)+' - '+num2str(dem_lr[1],dp=4)+']',chars=1.2
		oplot,[0,10],[0,10],color=200,linestyle=2, thick=2.0
		xyouts,0.5*maxpt,0.05*maxpt,'SHOT: '+num2str(shot,1)+' TIME: '+num2str(time,dp=2)

		openwin,3
		makesym,10
		maxpt=max(te)
		plot, radpts,te,xtit='Major Radius [m]',ytit='T!le!n [keV]',psym=8,symsize=1.3,chars=1.3,/xsty
		oplot, radpts, em_te,color=100,thick=2.0
		oplot, radpts, em_te_new,color=200,thick=2.0		
	ENDIF

	output={in:te, out:em_te}
	IF keyword_set(debug) THEN stop
	RETURN,output
END
